<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Consensus Gallery | GenLayer Game</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: { extend: { colors: { primary: { 300: '#a5b4fc', 400: '#818cf8', 500: '#667eea', 600: '#5a67d8' } } } }
    }
  </script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%); min-height: 100vh; font-family: 'Inter', sans-serif; }
    .gradient-text { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .gradient-text-gold { background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .glass { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); }
    .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
    .btn-success { background: linear-gradient(135deg, #10B981 0%, #059669 100%); }
    .btn-warning { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse-dot { animation: pulse 2s ease-in-out infinite; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .animate-fade-in { animation: fadeIn 0.5s ease-out; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-spin { animation: spin 1s linear infinite; }
    .chat-scroll { max-height: 400px; overflow-y: auto; }
    .chat-scroll::-webkit-scrollbar { width: 6px; }
    .chat-scroll::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    .chat-scroll::-webkit-scrollbar-thumb { background: rgba(102,126,234,0.3); border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    const CONTRACT = {
      ADDRESS: '0x5c2F525BA54839338F9BC9Cd8DF7B656FBc5E7d0',
      NETWORK: 'GenLayer Studio',
      CHAIN_ID: '0x' + (10242).toString(16),
      RPC_URL: 'https://rpc.asimov.genlayer.com',
    };

    const CONFIG = {
      MAX_PLAYERS: 5,
      MIN_PLAYERS: 2,
      ENTRY_FEE: 0,
      WINNER_REWARD_PERCENT: 80,
      MIN_GAME_DURATION: 30,
      MAX_GAME_DURATION: 3 * 60,
      VOTE_DURATION: 30,
      WINNER_EXP: 100,
      CORRECT_VOTER_EXP: 30,
      PARTICIPANT_EXP: 10,
      ROOM_IDLE_TIMEOUT: 60,
      AI_FILL_DELAY: 10,
    };

    const AI_PLAYERS = [
      { address: '0xAI00000000000000000000000000000000000001', name: 'ArtBot_Alpha',
        descriptions: ['This artwork captures profound beauty and emotion.', 'The colors blend harmoniously creating a mesmerizing experience.', 'Deep symbolism in every brushstroke of this masterpiece.']},
      { address: '0xAI00000000000000000000000000000000000002', name: 'ArtBot_Beta',
        descriptions: ['The composition draws the eye naturally across the canvas.', 'Light and shadow play together in perfect balance.', 'This piece speaks to the human condition subtly.']},
      { address: '0xAI00000000000000000000000000000000000003', name: 'ArtBot_Gamma',
        descriptions: ['A stunning display of artistic technique and vision.', 'The mood here is both haunting and beautiful.', 'Every element serves a purpose in this crafted work.']},
      { address: '0xAI00000000000000000000000000000000000004', name: 'ArtBot_Delta',
        descriptions: ['The artist masterfully captures the essence of the subject.', 'There is a timeless quality to this remarkable piece.', 'I am moved by the emotional depth expressed here.']},
    ];

    const isAIPlayer = (address) => address && address.startsWith('0xAI');
    const STORAGE_KEY = 'consensus_gallery_data_v1';

    const ART_COLLECTION = [
      { id: 1, name: 'Starry Night', artist: 'Van Gogh', year: 1889, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/800px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg', fallback: 'https://www.moma.org/media/W1siZiIsIjQ2NzUxNyJdLFsicCIsImNvbnZlcnQiLCItcXVhbGl0eSA5MCAtcmVzaXplIDUxMng1MTJcdTAwM2UiXV0.jpg' },
      { id: 2, name: 'Persistence of Memory', artist: 'Dali', year: 1931, url: 'https://uploads4.wikiart.org/images/salvador-dali/the-persistence-of-memory-1931.jpg', fallback: 'https://www.dalipaintings.com/images/paintings/the-persistence-of-memory.jpg' },
      { id: 3, name: 'The Great Wave', artist: 'Hokusai', year: 1831, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Tsunami_by_hokusai_19th_century.jpg/800px-Tsunami_by_hokusai_19th_century.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/0/0a/The_Great_Wave_off_Kanagawa.jpg' },
      { id: 4, name: 'Girl with Pearl Earring', artist: 'Vermeer', year: 1665, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/1665_Girl_with_a_Pearl_Earring.jpg/800px-1665_Girl_with_a_Pearl_Earring.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/d/d7/Meisje_met_de_parel.jpg' },
      { id: 5, name: 'The Scream', artist: 'Munch', year: 1893, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Edvard_Munch%2C_1893%2C_The_Scream%2C_oil%2C_tempera_and_pastel_on_cardboard%2C_91_x_73_cm%2C_National_Gallery_of_Norway.jpg/800px-Edvard_Munch%2C_1893%2C_The_Scream%2C_oil%2C_tempera_and_pastel_on_cardboard%2C_91_x_73_cm%2C_National_Gallery_of_Norway.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/f/f4/The_Scream.jpg' },
      { id: 6, name: 'Birth of Venus', artist: 'Botticelli', year: 1485, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/Sandro_Botticelli_-_La_nascita_di_Venere_-_Google_Art_Project_-_edited.jpg/800px-Sandro_Botticelli_-_La_nascita_di_Venere_-_Google_Art_Project_-_edited.jpg', fallback: 'https://www.uffizi.it/immagini/opere/botticelli-venere/botticelli-nascita-venere.jpg' },
      { id: 7, name: 'American Gothic', artist: 'Wood', year: 1930, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Grant_Wood_-_American_Gothic_-_Google_Art_Project.jpg/800px-Grant_Wood_-_American_Gothic_-_Google_Art_Project.jpg', fallback: 'https://www.artic.edu/iiif/2/b272df73-a965-ac37-4172-be4e99483637/full/843,/0/default.jpg' },
      { id: 8, name: 'The Kiss', artist: 'Klimt', year: 1908, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/The_Kiss_-_Gustav_Klimt_-_Google_Cultural_Institute.jpg/800px-The_Kiss_-_Gustav_Klimt_-_Google_Cultural_Institute.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/f/f3/Gustav_Klimt_016.jpg' },
    ];

    const ADJECTIVES = ['Swift', 'Brave', 'Wise', 'Noble', 'Silent', 'Golden', 'Silver', 'Cosmic', 'Mystic', 'Ancient'];
    const NOUNS = ['Phoenix', 'Dragon', 'Tiger', 'Eagle', 'Wolf', 'Hawk', 'Lion', 'Bear', 'Serpent', 'Falcon'];

    const generatePlayerId = (address) => {
      const aiPlayer = AI_PLAYERS.find(ai => ai.address === address);
      if (aiPlayer) return aiPlayer.name;
      const hash = address.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
      return `${ADJECTIVES[hash % ADJECTIVES.length]}${NOUNS[(hash * 7) % NOUNS.length]}${(hash % 99) + 1}`;
    };

    const shortenAddress = (addr) => addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
    const formatTime = (s) => `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
    const getArt = (id) => ART_COLLECTION.find(a => a.id === id) || ART_COLLECTION[0];
    const getRandomArt = () => ART_COLLECTION[Math.floor(Math.random() * ART_COLLECTION.length)];

    const getStorage = () => { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || null; } catch { return null; } };
    const setStorage = (data) => { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch {} };
    const createInitialState = () => ({ rooms: {}, leaderboard: {}, totalGames: 0, playerIds: {}, gameHistory: [] });

    const cleanupRooms = (state) => {
      const now = Date.now();
      const cleanedRooms = {};
      Object.entries(state.rooms || {}).forEach(([id, room]) => {
        if (room.phase === 'finished') return;
        if (room.phase === 'waiting' && room.players.length === 1 && (now - room.createdAt) > CONFIG.ROOM_IDLE_TIMEOUT * 1000) return;
        cleanedRooms[id] = room;
      });
      return { ...state, rooms: cleanedRooms };
    };

    const phaseLabels = { waiting: 'Waiting', playing: 'Playing', voting: 'Voting', finished: 'Finished' };
    const phaseColors = { waiting: '#6B7280', playing: '#10B981', voting: '#F59E0B', finished: '#8B5CF6' };
    const Spinner = () => <div className="inline-block w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>;

    const ArtDisplay = ({ artId, size = 280 }) => {
      const art = getArt(artId);
      const [loaded, setLoaded] = useState(false);
      const [error, setError] = useState(false);
      const [imgSrc, setImgSrc] = useState(art.url);
      const handleError = () => { if (!error && art.fallback) { setError(true); setImgSrc(art.fallback); } };
      return (
        <div className="relative flex-shrink-0" style={{ width: size, height: size }}>
          {!loaded && <div className="absolute inset-0 flex items-center justify-center bg-white/5 rounded-xl"><Spinner /></div>}
          <img src={imgSrc} alt={art.name} onLoad={() => setLoaded(true)} onError={handleError} crossOrigin="anonymous"
            className={`w-full h-full object-cover rounded-xl shadow-xl transition-opacity ${loaded ? 'opacity-100' : 'opacity-0'}`} />
          {size > 80 && (
            <div className="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent rounded-b-xl">
              <div className="text-sm font-medium text-white truncate">{art.name}</div>
              <div className="text-xs text-gray-300 truncate">{art.artist}, {art.year}</div>
            </div>
          )}
        </div>
      );
    };

    function App() {
      const [wallet, setWallet] = useState({ connected: false, address: '' });
      const [globalState, setGlobalState] = useState(() => {
        const stored = getStorage();
        return stored ? cleanupRooms({ ...createInitialState(), ...stored }) : createInitialState();
      });
      const [activeTab, setActiveTab] = useState('lobby');
      const [currentRoomId, setCurrentRoomId] = useState(null);
      const [message, setMessage] = useState('');
      const [error, setError] = useState('');
      const [success, setSuccess] = useState('');
      const [processing, setProcessing] = useState(false);
      const [timeLeft, setTimeLeft] = useState(0);
      const [lastFinishedGameId, setLastFinishedGameId] = useState(null);
      
      const globalStateRef = useRef(globalState);
      globalStateRef.current = globalState;
      const currentRoomIdRef = useRef(currentRoomId);
      currentRoomIdRef.current = currentRoomId;
      const chatEndRef = useRef(null);
      const currentRoom = currentRoomId ? globalState.rooms[currentRoomId] : null;

      const getPlayerId = useCallback((address) => {
        if (!address) return '';
        if (globalState.playerIds[address]) return globalState.playerIds[address];
        const newId = generatePlayerId(address);
        setGlobalState(prev => ({ ...prev, playerIds: { ...prev.playerIds, [address]: newId } }));
        return newId;
      }, [globalState.playerIds]);

      useEffect(() => { setStorage(globalState); }, [globalState]);
      
      useEffect(() => {
        const handleStorage = (e) => {
          if (e.key === STORAGE_KEY && e.newValue) {
            try { setGlobalState(cleanupRooms({ ...createInitialState(), ...JSON.parse(e.newValue) })); } catch {}
          }
        };
        window.addEventListener('storage', handleStorage);
        const syncInterval = setInterval(() => {
          const stored = getStorage();
          if (stored) {
            const cleaned = cleanupRooms({ ...createInitialState(), ...stored });
            if (JSON.stringify(globalStateRef.current) !== JSON.stringify(cleaned)) setGlobalState(cleaned);
          }
        }, 2000);
        return () => { window.removeEventListener('storage', handleStorage); clearInterval(syncInterval); };
      }, []);

      useEffect(() => {
        const timer = setInterval(() => {
          const roomId = currentRoomIdRef.current;
          if (!roomId) return;
          const room = globalStateRef.current.rooms[roomId];
          if (!room || room.phase === 'finished' || room.phase === 'waiting') { setTimeLeft(0); return; }
          const now = Date.now();
          const elapsed = Math.floor((now - room.startTime) / 1000);
          const remaining = room.phase === 'voting' ? Math.max(0, Math.floor((room.voteDeadline - now) / 1000)) : CONFIG.MAX_GAME_DURATION - elapsed;
          setTimeLeft(Math.max(0, remaining));
          if (room.phase === 'playing' && elapsed >= CONFIG.MAX_GAME_DURATION) handleStartVoting(roomId);
          else if (room.phase === 'voting' && remaining <= 0) handleFinalizeGame(roomId);
        }, 1000);
        return () => clearInterval(timer);
      }, []);

      useEffect(() => { if (chatEndRef.current) chatEndRef.current.scrollIntoView({ behavior: 'smooth' }); }, [currentRoom?.messages?.length]);

      const connectWallet = async () => {
        if (typeof window.ethereum === 'undefined') { setError('Please install MetaMask!'); setTimeout(() => setError(''), 4000); return; }
        setProcessing(true);
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          if (accounts && accounts.length > 0) {
            setWallet({ connected: true, address: accounts[0] });
            getPlayerId(accounts[0]);
            setSuccess('Wallet Connected!');
            setTimeout(() => setSuccess(''), 3000);
          }
        } catch (err) { setError('Failed to connect wallet'); setTimeout(() => setError(''), 4000); }
        setProcessing(false);
      };

      useEffect(() => {
        if (typeof window.ethereum !== 'undefined') {
          const handler = (accounts) => {
            if (accounts.length === 0) setWallet({ connected: false, address: '' });
            else { setWallet({ connected: true, address: accounts[0] }); getPlayerId(accounts[0]); }
          };
          window.ethereum.on('accountsChanged', handler);
          return () => window.ethereum.removeListener('accountsChanged', handler);
        }
      }, []);

      const sendTransaction = async (toAddress, amountInEth) => {
        if (!window.ethereum) throw new Error('MetaMask not found');
        const amountWei = '0x' + Math.floor(amountInEth * 1e18).toString(16);
        return await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: wallet.address, to: toAddress, value: amountWei }] });
      };

      const handleCreateRoom = async () => {
        if (!wallet.connected) { setError('Please connect wallet first'); setTimeout(() => setError(''), 4000); return; }
        setProcessing(true);
        let newRoomId = null;
        try {
          await sendTransaction(CONTRACT.ADDRESS, CONFIG.ENTRY_FEE);
          const art = getRandomArt();
          newRoomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
          const room = { id: newRoomId, gameNumber: globalState.totalGames + 1, creator: wallet.address, phase: 'waiting', artId: art.id, artName: art.name, maxPlayers: CONFIG.MAX_PLAYERS, players: [wallet.address], pool: CONFIG.ENTRY_FEE, messages: [], votes: {}, endGameVotes: [], winner: null, createdAt: Date.now(), startTime: null, voteDeadline: null, locked: false };
          setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [newRoomId]: room }, totalGames: prev.totalGames + 1 }));
          setCurrentRoomId(newRoomId);
          setActiveTab('game');
          setSuccess('Room Created!');
          setTimeout(() => setSuccess(''), 3000);
        } catch (err) { setError(err.code === 4001 ? 'Transaction cancelled' : 'Failed to create room'); setTimeout(() => setError(''), 4000); setProcessing(false); return; }
        setProcessing(false);
        if (newRoomId) {
          setTimeout(() => {
            setGlobalState(prev => {
              const room = prev.rooms[newRoomId];
              if (!room || room.phase !== 'waiting' || room.players.length > 1) return prev;
              return { ...prev, rooms: { ...prev.rooms, [newRoomId]: { ...room, players: [...room.players, ...AI_PLAYERS.map(ai => ai.address)] } } };
            });
          }, CONFIG.AI_FILL_DELAY * 1000);
        }
      };

      const handleJoinRoom = async (roomId) => {
        if (!wallet.connected) { setError('Please connect wallet first'); setTimeout(() => setError(''), 4000); return; }
        const room = globalState.rooms[roomId];
        if (!room || room.phase !== 'waiting' || room.locked) { setError('Room unavailable'); setTimeout(() => setError(''), 3000); return; }
        if (room.players.length >= room.maxPlayers) { setError('Room is full'); setTimeout(() => setError(''), 3000); return; }
        if (room.players.includes(wallet.address)) { setCurrentRoomId(roomId); setActiveTab('game'); return; }
        setProcessing(true);
        try {
          await sendTransaction(CONTRACT.ADDRESS, CONFIG.ENTRY_FEE);
          setGlobalState(prev => {
            const r = prev.rooms[roomId];
            if (!r) return prev;
            return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...r, players: [...r.players, wallet.address], pool: (r.pool || 0) + CONFIG.ENTRY_FEE } } };
          });
          setCurrentRoomId(roomId);
          setActiveTab('game');
          setSuccess('Joined Room!');
          setTimeout(() => setSuccess(''), 3000);
        } catch (err) { setError(err.code === 4001 ? 'Transaction cancelled' : 'Failed to join'); setTimeout(() => setError(''), 4000); }
        setProcessing(false);
      };

      const handleStartGame = (roomId) => {
        const room = globalState.rooms[roomId];
        if (!room || room.phase !== 'waiting' || room.players.length < CONFIG.MIN_PLAYERS) return;
        setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [roomId]: { ...prev.rooms[roomId], phase: 'playing', locked: true, startTime: Date.now() } } }));
        room.players.filter(isAIPlayer).forEach((aiAddr, idx) => {
          const ai = AI_PLAYERS.find(a => a.address === aiAddr);
          if (!ai) return;
          setTimeout(() => {
            setGlobalState(prev => {
              const r = prev.rooms[roomId];
              if (!r || r.phase !== 'playing') return prev;
              return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...r, messages: [...r.messages, { id: Date.now() + idx, author: aiAddr, content: ai.descriptions[Math.floor(Math.random() * ai.descriptions.length)], timestamp: Date.now() }] } } };
            });
          }, 5000 + Math.random() * 25000 + idx * 3000);
        });
      };

      const handleSendMessage = () => {
        if (!wallet.connected || !currentRoomId || !message.trim()) return;
        const room = globalState.rooms[currentRoomId];
        if (!room || room.phase !== 'playing') return;
        setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [currentRoomId]: { ...room, messages: [...room.messages, { id: Date.now(), author: wallet.address, content: message.trim(), timestamp: Date.now() }] } } }));
        setMessage('');
      };

      const handleVoteEndGame = () => {
        if (!wallet.connected || !currentRoomId) return;
        const room = globalState.rooms[currentRoomId];
        if (!room || room.phase !== 'playing' || (Date.now() - room.startTime) / 1000 < CONFIG.MIN_GAME_DURATION || room.endGameVotes.includes(wallet.address)) return;
        const newVotes = [...room.endGameVotes, wallet.address];
        const shouldEnd = newVotes.length >= Math.ceil(room.players.length / 2);
        setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [currentRoomId]: { ...room, endGameVotes: newVotes, ...(shouldEnd ? { phase: 'voting', voteDeadline: Date.now() + CONFIG.VOTE_DURATION * 1000 } : {}) } } }));
      };

      const handleStartVoting = (roomId) => {
        setGlobalState(prev => {
          const room = prev.rooms[roomId];
          if (!room || room.phase !== 'playing') return prev;
          return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...room, phase: 'voting', voteDeadline: Date.now() + CONFIG.VOTE_DURATION * 1000 } } };
        });
        setTimeout(() => {
          setGlobalState(prev => {
            const room = prev.rooms[roomId];
            if (!room || room.phase !== 'voting') return prev;
            const authors = [...new Set(room.messages.map(m => m.author))];
            const humans = authors.filter(a => !isAIPlayer(a));
            const newVotes = { ...room.votes };
            room.players.filter(isAIPlayer).forEach(ai => {
              if (!newVotes[ai] && authors.includes(ai)) {
                newVotes[ai] = humans.length > 0 ? humans[Math.floor(Math.random() * humans.length)] : authors[Math.floor(Math.random() * authors.length)];
              }
            });
            return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...room, votes: newVotes } } };
          });
        }, 3000);
      };

      const handleVote = (targetAddress) => {
        if (!wallet.connected || !currentRoomId) return;
        const room = globalState.rooms[currentRoomId];
        if (!room || room.phase !== 'voting' || room.votes[wallet.address]) { setError('Already voted'); setTimeout(() => setError(''), 3000); return; }
        const newVotes = { ...room.votes, [wallet.address]: targetAddress };
        const authors = [...new Set(room.messages.map(m => m.author))];
        if (authors.every(p => newVotes[p])) setGlobalState(prev => finalizeGameState(prev, currentRoomId, newVotes));
        else setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [currentRoomId]: { ...room, votes: newVotes } } }));
      };

      const handleFinalizeGame = (roomId) => {
        setGlobalState(prev => {
          const room = prev.rooms[roomId];
          if (!room || room.phase === 'finished') return prev;
          return finalizeGameState(prev, roomId, room.votes || {});
        });
      };

      const finalizeGameState = (prevState, roomId, votes) => {
        const room = prevState.rooms[roomId];
        if (!room || room.phase === 'finished') return prevState;
        const authors = [...new Set(room.messages.map(m => m.author))];
        if (authors.length === 0) { const newRooms = { ...prevState.rooms }; delete newRooms[roomId]; return { ...prevState, rooms: newRooms }; }
        const voteCount = {}; authors.forEach(addr => { voteCount[addr] = 0; });
        Object.values(votes).forEach(target => { if (voteCount[target] !== undefined) voteCount[target]++; });
        const maxVotes = Math.max(...Object.values(voteCount), 0);
        const winners = authors.filter(addr => voteCount[addr] === maxVotes);
        const winnerAddress = winners[Math.floor(Math.random() * winners.length)];
        const pool = room.pool || (room.players.length * CONFIG.ENTRY_FEE);
        const winnerReward = pool * (CONFIG.WINNER_REWARD_PERCENT / 100);
        const newLeaderboard = JSON.parse(JSON.stringify(prevState.leaderboard));
        
        if (!newLeaderboard[winnerAddress]) newLeaderboard[winnerAddress] = { experience: 0, wins: 0, participations: 0, totalRewards: 0 };
        newLeaderboard[winnerAddress].experience += CONFIG.WINNER_EXP;
        newLeaderboard[winnerAddress].wins += 1;
        newLeaderboard[winnerAddress].totalRewards = (newLeaderboard[winnerAddress].totalRewards || 0) + winnerReward;
        
        Object.entries(votes).forEach(([voter, target]) => {
          if (isAIPlayer(voter)) return;
          if (!newLeaderboard[voter]) newLeaderboard[voter] = { experience: 0, wins: 0, participations: 0, totalRewards: 0 };
          newLeaderboard[voter].experience += target === winnerAddress ? CONFIG.CORRECT_VOTER_EXP : CONFIG.PARTICIPANT_EXP;
          newLeaderboard[voter].participations += 1;
        });
        
        authors.filter(a => !isAIPlayer(a) && !votes[a]).forEach(addr => {
          if (!newLeaderboard[addr]) newLeaderboard[addr] = { experience: 0, wins: 0, participations: 0, totalRewards: 0 };
          newLeaderboard[addr].participations += 1;
          newLeaderboard[addr].experience += CONFIG.PARTICIPANT_EXP;
        });
        
        const gameRecord = { id: roomId, gameNumber: room.gameNumber, artId: room.artId, artName: room.artName, players: room.players.filter(p => !isAIPlayer(p)), winner: winnerAddress, winnerReward, voteCount, votes, finishedAt: Date.now() };
        const gameHistory = [...(prevState.gameHistory || []), gameRecord].slice(-100);
        
        setTimeout(() => { setLastFinishedGameId(roomId); setActiveTab('history'); setCurrentRoomId(null); }, 2000);
        
        return { ...prevState, leaderboard: newLeaderboard, gameHistory, rooms: { ...prevState.rooms, [roomId]: { ...room, phase: 'finished', votes, winner: winnerAddress, voteCount, winnerReward } } };
      };

      const handleLeaveRoom = () => { setCurrentRoomId(null); setActiveTab('lobby'); setMessage(''); };

      const availableRooms = useMemo(() => {
        const now = Date.now();
        return Object.values(globalState.rooms).filter(r => r.phase === 'waiting' && !r.locked && r.players.length < r.maxPlayers && !(r.players.length === 1 && (now - r.createdAt) > CONFIG.ROOM_IDLE_TIMEOUT * 1000));
      }, [globalState.rooms]);
      
      const myRooms = useMemo(() => Object.values(globalState.rooms).filter(r => wallet.connected && r.players.includes(wallet.address) && r.phase !== 'finished'), [globalState.rooms, wallet]);
      const myGameHistory = useMemo(() => !wallet.connected ? [] : (globalState.gameHistory || []).filter(g => g.players.includes(wallet.address)).reverse().slice(0, 50), [globalState.gameHistory, wallet]);
      const sortedLeaderboard = useMemo(() => Object.entries(globalState.leaderboard).filter(([addr]) => !isAIPlayer(addr)).map(([address, stats]) => ({ address, playerId: globalState.playerIds[address] || generatePlayerId(address), experience: stats.experience || 0, wins: stats.wins || 0, participations: stats.participations || 0, totalRewards: stats.totalRewards || 0 })).sort((a, b) => b.totalRewards - a.totalRewards || b.experience - a.experience), [globalState.leaderboard, globalState.playerIds]);

      const gameElapsed = currentRoom?.startTime ? Math.floor((Date.now() - currentRoom.startTime) / 1000) : 0;
      const canVoteEnd = currentRoom?.phase === 'playing' && gameElapsed >= CONFIG.MIN_GAME_DURATION;
      const endVoteProgress = currentRoom ? `${currentRoom.endGameVotes?.length || 0}/${Math.ceil(currentRoom.players.length / 2)}` : '';
      const myPlayerId = wallet.connected ? (globalState.playerIds[wallet.address] || generatePlayerId(wallet.address)) : '';
      const myStats = wallet.connected ? (globalState.leaderboard[wallet.address] || { experience: 0, totalRewards: 0 }) : { experience: 0, totalRewards: 0 };

      return (
        <div className="min-h-screen text-gray-200">
          <header className="flex justify-between items-center px-4 md:px-6 py-4 border-b border-white/10">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-xl flex items-center justify-center text-xl btn-primary">üé®</div>
              <h1 className="text-lg md:text-xl font-bold gradient-text">Consensus Gallery</h1>
            </div>
            <div className="flex items-center gap-2">
              {wallet.connected ? (
                <div className="flex items-center gap-2 px-3 py-2 glass rounded-xl">
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span className="text-xs md:text-sm font-medium">{myPlayerId}</span>
                  <span className="px-2 py-0.5 bg-primary-500/30 rounded text-xs font-bold text-primary-300">{myStats.experience || 0} XP</span>
                  <span className="px-2 py-0.5 bg-yellow-500/30 rounded text-xs font-bold text-yellow-300">{(myStats.totalRewards || 0).toFixed(4)} GEN</span>
                </div>
              ) : (
                <button onClick={connectWallet} disabled={processing} className="btn-primary px-4 py-2 rounded-xl text-white text-sm font-semibold flex items-center gap-2">
                  {processing ? <><Spinner /> Connecting...</> : 'ü¶ä Connect'}
                </button>
              )}
            </div>
          </header>

          {error && <div className="fixed top-20 left-1/2 -translate-x-1/2 z-50 px-4 py-3 bg-red-500/90 text-white rounded-lg shadow-lg animate-fade-in flex items-center gap-3 max-w-md"><span className="text-sm">{error}</span><button onClick={() => setError('')} className="ml-2">‚úï</button></div>}
          {success && <div className="fixed top-20 left-1/2 -translate-x-1/2 z-50 px-4 py-3 bg-green-500/90 text-white rounded-lg shadow-lg animate-fade-in">‚úì {success}</div>}

          <nav className="flex gap-1 px-4 md:px-6 py-3 border-b border-white/5 overflow-x-auto">
            {[{ id: 'lobby', icon: 'üè†', label: 'Lobby' }, { id: 'game', icon: 'üéÆ', label: 'Game', badge: myRooms.length > 0 ? myRooms.length : null }, { id: 'history', icon: 'üìú', label: 'History' }, { id: 'leaderboard', icon: 'üèÜ', label: 'Rankings' }].map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)} className={`px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-1.5 whitespace-nowrap ${activeTab === tab.id ? 'bg-primary-500/20 border border-primary-500/50 text-primary-300' : 'text-gray-400 hover:bg-white/5'}`}>
                <span>{tab.icon}</span><span className="hidden sm:inline">{tab.label}</span>
                {tab.badge && <span className="px-1.5 py-0.5 text-xs bg-red-500 text-white rounded-full">{tab.badge}</span>}
              </button>
            ))}
          </nav>

          <main className="px-4 md:px-6 py-6 max-w-6xl mx-auto">
            {activeTab === 'lobby' && (
              <div className="space-y-6 animate-fade-in">
                <div className="text-center py-6">
                  <h2 className="text-2xl md:text-3xl font-bold gradient-text mb-2">Consensus Gallery</h2>
                  <p className="text-gray-400">Win: +{CONFIG.WINNER_EXP} XP | Correct Vote: +{CONFIG.CORRECT_VOTER_EXP} XP | Participate: +{CONFIG.PARTICIPANT_EXP} XP</p>
                </div>
                
                {!wallet.connected ? (
                  <div className="glass rounded-2xl p-8 text-center">
                    <div className="text-5xl mb-4">ü¶ä</div>
                    <h3 className="text-xl font-bold mb-2">Connect MetaMask</h3>
                    <p className="text-gray-400 mb-6">Connect your wallet to start playing</p>
                    <button onClick={connectWallet} disabled={processing} className="btn-primary px-8 py-3 rounded-xl text-white font-semibold text-lg">{processing ? <><Spinner /> Connecting...</> : 'Connect Wallet'}</button>
                  </div>
                ) : (
                  <>
                    <div className="glass rounded-2xl p-6">
                      <h3 className="text-lg font-semibold mb-2">üéÆ Create New Game</h3>
                      <p className="text-sm text-gray-400 mb-4">Entry: {CONFIG.ENTRY_FEE} GEN | Game: {CONFIG.MAX_GAME_DURATION / 60}min | Vote: {CONFIG.VOTE_DURATION}s</p>
                      <button onClick={handleCreateRoom} disabled={processing} className="btn-primary w-full py-4 rounded-xl font-semibold flex items-center justify-center gap-2 text-white">{processing ? <><Spinner /> Processing...</> : `‚ú® Create Room (${CONFIG.ENTRY_FEE} GEN)`}</button>
                    </div>

                    <div className="glass rounded-2xl p-6">
                      <h3 className="text-lg font-semibold mb-4">üö™ Available Rooms ({availableRooms.length})</h3>
                      {availableRooms.length === 0 ? <div className="text-center py-8 text-gray-500">No rooms available. Create one!</div> : (
                        <div className="space-y-3">
                          {availableRooms.map(room => (
                            <div key={room.id} className="flex items-center justify-between p-4 bg-white/5 rounded-xl hover:bg-white/10 transition">
                              <div className="flex items-center gap-4">
                                <ArtDisplay artId={room.artId} size={60} />
                                <div>
                                  <div className="font-medium">{room.artName}</div>
                                  <div className="text-sm text-gray-400">üë• {room.players?.length || 0}/{room.maxPlayers} | Host: {globalState.playerIds[room.creator] || generatePlayerId(room.creator)}</div>
                                </div>
                              </div>
                              <button onClick={() => handleJoinRoom(room.id)} disabled={processing} className="btn-success px-4 py-2 rounded-lg text-white text-sm font-medium">{processing ? <Spinner /> : 'Join'}</button>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>

                    {myRooms.length > 0 && (
                      <div className="glass rounded-2xl p-6 border-primary-500/30">
                        <h3 className="text-lg font-semibold mb-4 text-primary-300">‚è≥ My Games</h3>
                        <div className="space-y-3">
                          {myRooms.map(room => (
                            <div key={room.id} className="flex items-center justify-between p-4 bg-primary-500/10 rounded-xl">
                              <div className="flex items-center gap-4">
                                <ArtDisplay artId={room.artId} size={50} />
                                <div><div className="font-medium text-sm">{room.artName}</div><div className="text-xs text-gray-400">{phaseLabels[room.phase]} | üë• {room.players?.length || 0}</div></div>
                              </div>
                              <button onClick={() => { setCurrentRoomId(room.id); setActiveTab('game'); }} className="btn-warning px-4 py-2 rounded-lg text-white text-sm font-medium">Enter</button>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                )}

                <div className="grid grid-cols-2 gap-4">
                  <div className="glass rounded-xl p-4 text-center"><div className="text-2xl mb-1">üéÆ</div><div className="text-2xl font-bold">{globalState.totalGames}</div><div className="text-xs text-gray-500">Total Games</div></div>
                  <div className="glass rounded-xl p-4 text-center"><div className="text-2xl mb-1">üë•</div><div className="text-2xl font-bold">{Object.keys(globalState.leaderboard).filter(a => !isAIPlayer(a)).length}</div><div className="text-xs text-gray-500">Players</div></div>
                </div>
              </div>
            )}

            {activeTab === 'game' && (
              <div className="animate-fade-in">
                {!currentRoom ? (
                  <div className="glass rounded-2xl p-8 text-center"><p className="text-gray-400 mb-4">No active game</p><button onClick={() => setActiveTab('lobby')} className="btn-primary px-6 py-3 rounded-xl text-white font-semibold">Go to Lobby</button></div>
                ) : (
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div className="space-y-4">
                      <div className="glass rounded-xl p-4">
                        <div className="flex items-center justify-between">
                          <span className="px-3 py-1 rounded-full text-sm font-semibold flex items-center gap-2" style={{ background: phaseColors[currentRoom.phase] + '20', color: phaseColors[currentRoom.phase] }}><span className="w-2 h-2 rounded-full pulse-dot" style={{ background: phaseColors[currentRoom.phase] }}></span>{phaseLabels[currentRoom.phase]}</span>
                          {(currentRoom.phase === 'playing' || currentRoom.phase === 'voting') && <div className={`px-3 py-1.5 rounded-lg ${timeLeft <= 30 ? 'bg-red-500/20 text-red-400' : 'bg-white/5'}`}><span className="text-xl font-bold font-mono">{formatTime(timeLeft)}</span></div>}
                        </div>
                      </div>

                      <div className="glass rounded-xl p-6 text-center">
                        <ArtDisplay artId={currentRoom.artId} size={300} />
                        {currentRoom.phase === 'waiting' && (
                          <div className="mt-4 p-3 bg-white/5 rounded-lg">
                            <div className="text-sm text-gray-400 mb-2">Players ({currentRoom.players?.length || 0}/{currentRoom.maxPlayers})</div>
                            <div className="flex flex-wrap gap-2 justify-center">
                              {currentRoom.players?.map(addr => (
                                <span key={addr} className={`px-2 py-1 rounded text-xs ${addr === wallet.address ? 'bg-primary-500/30 text-primary-300' : isAIPlayer(addr) ? 'bg-yellow-500/20 text-yellow-300' : 'bg-white/10'}`}>{isAIPlayer(addr) && 'ü§ñ '}{globalState.playerIds[addr] || generatePlayerId(addr)}{addr === currentRoom.creator && ' üëë'}</span>
                              ))}
                            </div>
                            {currentRoom.creator === wallet.address && currentRoom.players?.length >= CONFIG.MIN_PLAYERS && <button onClick={() => handleStartGame(currentRoomId)} className="btn-success w-full mt-4 py-3 rounded-lg text-white font-semibold">üöÄ Start Game</button>}
                            {currentRoom.players?.length < CONFIG.MIN_PLAYERS && <p className="text-sm text-yellow-500 mt-3">Waiting for players... (AI joins in {CONFIG.AI_FILL_DELAY}s)</p>}
                          </div>
                        )}
                        {currentRoom.phase === 'playing' && canVoteEnd && (
                          <div className="mt-4 p-3 bg-yellow-500/10 rounded-lg border border-yellow-500/20">
                            <button onClick={handleVoteEndGame} disabled={currentRoom.endGameVotes?.includes(wallet.address)} className={`w-full py-2 rounded-lg font-medium ${currentRoom.endGameVotes?.includes(wallet.address) ? 'bg-white/10 text-gray-500' : 'btn-warning text-white'}`}>{currentRoom.endGameVotes?.includes(wallet.address) ? `‚úì Voted (${endVoteProgress})` : `End Early (${endVoteProgress})`}</button>
                          </div>
                        )}
                      </div>

                      {currentRoom.phase === 'finished' && currentRoom.winner && (
                        <div className="rounded-xl p-6 text-center" style={{ background: 'linear-gradient(135deg, rgba(139,92,246,0.2), rgba(236,72,153,0.2))', border: '1px solid rgba(139,92,246,0.3)' }}>
                          <div className="text-4xl mb-3">üèÜ</div>
                          <h3 className="text-xl font-bold mb-2">Game Over!</h3>
                          <p className="text-sm text-gray-400 mb-2">Winner: {globalState.playerIds[currentRoom.winner] || generatePlayerId(currentRoom.winner)}</p>
                          {currentRoom.winner === wallet.address && <p className="text-green-400 mt-2">üéâ You won! +{CONFIG.WINNER_EXP} XP</p>}
                          <p className="text-xs text-gray-500 mt-2">Redirecting to history...</p>
                        </div>
                      )}
                      {currentRoom.phase !== 'finished' && <button onClick={handleLeaveRoom} className="w-full py-2 text-sm text-gray-500 hover:text-gray-300">Leave Room</button>}
                    </div>

                    <div className="space-y-4">
                      {currentRoom.phase === 'playing' && (
                        <div className="glass rounded-xl p-5">
                          <h3 className="font-semibold mb-3">üí¨ Describe the Art</h3>
                          <div className="chat-scroll mb-4 space-y-2 p-2 bg-black/20 rounded-lg min-h-[200px]">
                            {currentRoom.messages?.length === 0 ? <div className="text-center py-8 text-gray-500 text-sm">Start describing!</div> : currentRoom.messages?.map(msg => (
                              <div key={msg.id} className={`p-3 rounded-lg ${msg.author === wallet.address ? 'bg-primary-500/20 ml-8' : isAIPlayer(msg.author) ? 'bg-yellow-500/10 mr-8' : 'bg-white/5 mr-8'}`}>
                                <div className="flex justify-between items-start mb-1"><span className="text-xs font-medium text-gray-400">{isAIPlayer(msg.author) && 'ü§ñ '}{globalState.playerIds[msg.author] || generatePlayerId(msg.author)}</span><span className="text-xs text-gray-500">{new Date(msg.timestamp).toLocaleTimeString()}</span></div>
                                <p className="text-gray-200">{msg.content}</p>
                              </div>
                            ))}
                            <div ref={chatEndRef} />
                          </div>
                          <div className="flex gap-2">
                            <input type="text" value={message} onChange={e => setMessage(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleSendMessage()} placeholder="Describe the art..." className="flex-1 px-4 py-2 rounded-lg bg-black/30 border border-white/10 text-gray-200 focus:outline-none focus:border-primary-500/50" />
                            <button onClick={handleSendMessage} disabled={!message.trim()} className={`px-4 py-2 rounded-lg font-medium ${message.trim() ? 'btn-success text-white' : 'bg-white/10 text-gray-500'}`}>Send</button>
                          </div>
                        </div>
                      )}

                      {currentRoom.phase === 'voting' && (
                        <div className="glass rounded-xl p-5">
                          <h3 className="font-semibold mb-2">üó≥Ô∏è Vote for Best Description</h3>
                          <p className="text-xs text-gray-400 mb-4">Correct vote = +{CONFIG.CORRECT_VOTER_EXP} XP | Participate = +{CONFIG.PARTICIPANT_EXP} XP</p>
                          <div className="space-y-3">
                            {[...new Set(currentRoom.messages?.map(m => m.author) || [])].map(addr => {
                              const authorMsgs = currentRoom.messages?.filter(m => m.author === addr) || [];
                              const isVoted = currentRoom.votes?.[wallet.address] === addr;
                              const voteCount = Object.values(currentRoom.votes || {}).filter(v => v === addr).length;
                              return (
                                <div key={addr} onClick={() => !currentRoom.votes?.[wallet.address] && handleVote(addr)} className={`p-4 rounded-lg transition ${isVoted ? 'bg-primary-500/20 border border-primary-500/40' : 'bg-white/5 border border-white/5'} ${!currentRoom.votes?.[wallet.address] ? 'cursor-pointer hover:bg-white/10' : ''}`}>
                                  <div className="flex justify-between items-center mb-2"><span className="text-sm font-medium">{isAIPlayer(addr) && 'ü§ñ '}{globalState.playerIds[addr] || generatePlayerId(addr)}{addr === wallet.address ? ' (You)' : ''}</span><span className="text-yellow-500 text-sm">üó≥Ô∏è {voteCount}</span></div>
                                  <div className="space-y-1">{authorMsgs.slice(0, 2).map((m, i) => <p key={i} className="text-sm text-gray-300 truncate">"{m.content}"</p>)}</div>
                                  {isVoted && <div className="mt-2 text-sm text-primary-400">‚úì Your vote</div>}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      )}

                      {currentRoom.phase === 'finished' && (
                        <div className="glass rounded-xl p-5">
                          <h3 className="font-semibold mb-4">üìä Final Results</h3>
                          <div className="space-y-2">
                            {[...new Set(currentRoom.messages?.map(m => m.author) || [])].sort((a, b) => (currentRoom.voteCount?.[b] || 0) - (currentRoom.voteCount?.[a] || 0)).map(addr => (
                              <div key={addr} className={`p-3 rounded-lg ${addr === currentRoom.winner ? 'bg-yellow-500/20' : 'bg-white/5'}`}>
                                <div className="flex justify-between"><span>{addr === currentRoom.winner && 'üèÜ '}{isAIPlayer(addr) && 'ü§ñ '}{globalState.playerIds[addr] || generatePlayerId(addr)}</span><span className="text-yellow-500">{currentRoom.voteCount?.[addr] || 0} votes</span></div>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}

            {activeTab === 'history' && (
              <div className="glass rounded-2xl p-6 animate-fade-in">
                <h2 className="text-2xl font-bold text-center gradient-text mb-6">üìú Game History</h2>
                {!wallet.connected ? <div className="text-center py-10 text-gray-500">Connect wallet to view history</div> : myGameHistory.length === 0 ? <div className="text-center py-10 text-gray-500">No games played yet</div> : (
                  <div className="space-y-3">
                    {myGameHistory.map((game) => {
                      const isWinner = game.winner === wallet.address;
                      const votedCorrectly = game.votes?.[wallet.address] === game.winner;
                      const xpEarned = isWinner ? CONFIG.WINNER_EXP : (votedCorrectly ? CONFIG.CORRECT_VOTER_EXP : CONFIG.PARTICIPANT_EXP);
                      const isRecent = game.id === lastFinishedGameId;
                      return (
                        <div key={game.id} className={`p-4 rounded-xl ${isRecent ? 'ring-2 ring-primary-500 bg-primary-500/10' : isWinner ? 'bg-yellow-500/10 border border-yellow-500/20' : 'bg-white/5'}`}>
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                              <ArtDisplay artId={game.artId} size={50} />
                              <div>
                                <div className="font-medium text-sm">{game.artName}</div>
                                <div className="text-xs text-gray-400">Game #{game.gameNumber} | {new Date(game.finishedAt).toLocaleDateString()}</div>
                                <div className="text-xs text-gray-500 mt-1">Winner: {globalState.playerIds[game.winner] || generatePlayerId(game.winner)}{isAIPlayer(game.winner) && ' ü§ñ'}</div>
                              </div>
                            </div>
                            <div className="text-right">
                              {isWinner ? <div className="text-yellow-400 font-bold">üèÜ Winner!</div> : votedCorrectly ? <div className="text-green-400 text-sm">‚úì Correct Vote</div> : <div className="text-gray-400 text-sm">Participated</div>}
                              <div className="text-sm text-primary-300">+{xpEarned} XP</div>
                              {isWinner && game.winnerReward > 0 && <div className="text-sm text-yellow-300">+{game.winnerReward.toFixed(4)} GEN</div>}
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            {activeTab === 'leaderboard' && (
              <div className="glass rounded-2xl p-6 animate-fade-in">
                <h2 className="text-2xl font-bold text-center gradient-text-gold mb-6">üèÜ Rankings (by Rewards)</h2>
                {sortedLeaderboard.length === 0 ? <div className="text-center py-10 text-gray-500">No players yet</div> : (
                  <div className="space-y-2">
                    {sortedLeaderboard.map((p, idx) => (
                      <div key={p.address} className={`grid grid-cols-[40px_1fr_80px_80px_60px] items-center p-3 rounded-lg ${idx === 0 ? 'bg-yellow-500/10' : p.address === wallet.address ? 'bg-primary-500/10' : 'bg-white/3'}`}>
                        <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-sm font-bold ${idx < 3 ? 'bg-gradient-to-br from-yellow-400 to-orange-500' : 'bg-white/10'}`}>{idx < 3 ? ['ü•á', 'ü•à', 'ü•â'][idx] : idx + 1}</div>
                        <span className="text-sm font-medium truncate">{p.playerId}{p.address === wallet.address && ' (You)'}</span>
                        <div className="text-center"><div className="font-bold text-yellow-300">{p.totalRewards.toFixed(4)}</div><div className="text-[10px] text-gray-500">GEN</div></div>
                        <div className="text-center"><div className="font-bold text-primary-300">{p.experience}</div><div className="text-[10px] text-gray-500">XP</div></div>
                        <div className="text-center"><div className="font-bold text-green-400">{p.wins}</div><div className="text-[10px] text-gray-500">Wins</div></div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </main>

          <footer className="text-center py-6 border-t border-white/5 mt-8"><p className="text-sm text-gray-500">Consensus Gallery | <a href="https://genlayer.com" target="_blank" className="text-primary-400 hover:underline">GenLayer</a></p></footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
