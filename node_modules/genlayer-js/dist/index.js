import {
  chains_exports,
  simulator
} from "./chunk-3TYB36DW.js";
import {
  Address
} from "./chunk-M7SA3INM.js";
import "./chunk-MLKGABMK.js";

// src/client/client.ts
import { createClient as createViemClient, publicActions, custom } from "viem";

// src/accounts/actions.ts
function accountActions(client) {
  return {
    fundAccount: async ({ address, amount }) => {
      if (client.chain?.id !== simulator.id) {
        throw new Error("Client is not connected to the simulator");
      }
      return client.request({
        method: "sim_fundAccount",
        params: [address, amount]
      });
    },
    getCurrentNonce: async ({ address, block = "latest" }) => {
      const addressToUse = address || client.account?.address;
      if (!addressToUse) {
        throw new Error("No address provided and no account is connected");
      }
      return client.request({
        method: "eth_getTransactionCount",
        params: [addressToUse, block]
      });
    }
  };
}

// src/abi/calldata/consts.ts
var BITS_IN_TYPE = 3;
var TYPE_SPECIAL = 0;
var TYPE_PINT = 1;
var TYPE_NINT = 2;
var TYPE_BYTES = 3;
var TYPE_STR = 4;
var TYPE_ARR = 5;
var TYPE_MAP = 6;
var SPECIAL_NULL = 0 << BITS_IN_TYPE | TYPE_SPECIAL;
var SPECIAL_FALSE = 1 << BITS_IN_TYPE | TYPE_SPECIAL;
var SPECIAL_TRUE = 2 << BITS_IN_TYPE | TYPE_SPECIAL;
var SPECIAL_ADDR = 3 << BITS_IN_TYPE | TYPE_SPECIAL;

// src/abi/calldata/decoder.ts
function readULeb128(data, index) {
  let res = 0n;
  let accum = 0n;
  let shouldContinue = true;
  while (shouldContinue) {
    const byte = data[index.i];
    index.i++;
    const rest = byte & 127;
    res += BigInt(rest) * (1n << accum);
    accum += 7n;
    shouldContinue = byte >= 128;
  }
  return res;
}
function decodeImpl(data, index) {
  const cur = readULeb128(data, index);
  switch (cur) {
    case BigInt(SPECIAL_NULL):
      return null;
    case BigInt(SPECIAL_TRUE):
      return true;
    case BigInt(SPECIAL_FALSE):
      return false;
    case BigInt(SPECIAL_ADDR): {
      const res = data.slice(index.i, index.i + 20);
      index.i += 20;
      return new Address(res);
    }
  }
  const type = Number(cur & 0xffn) & (1 << BITS_IN_TYPE) - 1;
  const rest = cur >> BigInt(BITS_IN_TYPE);
  switch (type) {
    case TYPE_BYTES: {
      const ret = data.slice(index.i, index.i + Number(rest));
      index.i += Number(rest);
      return ret;
    }
    case TYPE_PINT:
      return rest;
    case TYPE_NINT:
      return -1n - rest;
    case TYPE_STR: {
      const ret = data.slice(index.i, index.i + Number(rest));
      index.i += Number(rest);
      return new TextDecoder("utf-8").decode(ret);
    }
    case TYPE_ARR: {
      const ret = [];
      let elems = rest;
      while (elems > 0) {
        elems--;
        ret.push(decodeImpl(data, index));
      }
      return ret;
    }
    case TYPE_MAP: {
      const ret = /* @__PURE__ */ new Map();
      let elems = rest;
      while (elems > 0) {
        elems--;
        const strLen = Number(readULeb128(data, index));
        const key = data.slice(index.i, index.i + strLen);
        index.i += strLen;
        const keyStr = new TextDecoder("utf-8").decode(key);
        ret.set(keyStr, decodeImpl(data, index));
      }
      return ret;
    }
    default:
      throw new Error(`can't decode type from ${type} rest is ${rest} at pos ${index.i}`);
  }
}
function decode(data) {
  const index = { i: 0 };
  const res = decodeImpl(data, index);
  if (index.i !== data.length) {
    throw new Error("some data left");
  }
  return res;
}

// src/abi/calldata/encoder.ts
import { toHex } from "viem";
import { toRlp } from "viem";
function reportError(msg, data) {
  throw new Error(`invalid calldata input '${data}'`);
}
function writeNum(to, data) {
  if (data === 0n) {
    to.push(0);
    return;
  }
  while (data > 0) {
    let cur = Number(data & 0x7fn);
    data >>= 7n;
    if (data > 0) {
      cur |= 128;
    }
    to.push(cur);
  }
}
function encodeNumWithType(to, data, type) {
  const res = data << BigInt(BITS_IN_TYPE) | BigInt(type);
  writeNum(to, res);
}
function encodeNum(to, data) {
  if (data >= 0n) {
    encodeNumWithType(to, data, TYPE_PINT);
  } else {
    encodeNumWithType(to, -data - 1n, TYPE_NINT);
  }
}
function compareString(l, r) {
  for (let index = 0; index < l.length && index < r.length; index++) {
    const cur = l[index] - r[index];
    if (cur !== 0) {
      return cur;
    }
  }
  return l.length - r.length;
}
function encodeMap(to, arr) {
  const newEntries = Array.from(
    arr,
    ([k, v]) => [
      Array.from(k, (x) => x.codePointAt(0)),
      new TextEncoder().encode(k),
      v
    ]
  );
  newEntries.sort((v1, v2) => compareString(v1[0], v2[0]));
  for (let i = 1; i < newEntries.length; i++) {
    if (compareString(newEntries[i - 1][0], newEntries[i][0]) === 0) {
      throw new Error(`duplicate key '${new TextDecoder().decode(newEntries[i][1])}'`);
    }
  }
  encodeNumWithType(to, BigInt(newEntries.length), TYPE_MAP);
  for (const [, k, v] of newEntries) {
    writeNum(to, BigInt(k.length));
    for (const c of k) {
      to.push(c);
    }
    encodeImpl(to, v);
  }
}
function encodeImpl(to, data) {
  if (data === null || data === void 0) {
    to.push(SPECIAL_NULL);
    return;
  }
  if (data === true) {
    to.push(SPECIAL_TRUE);
    return;
  }
  if (data === false) {
    to.push(SPECIAL_FALSE);
    return;
  }
  switch (typeof data) {
    case "number": {
      if (!Number.isInteger(data)) {
        reportError("floats are not supported", data);
      }
      encodeNum(to, BigInt(data));
      return;
    }
    case "bigint": {
      encodeNum(to, data);
      return;
    }
    case "string": {
      const str = new TextEncoder().encode(data);
      encodeNumWithType(to, BigInt(str.length), TYPE_STR);
      for (const c of str) {
        to.push(c);
      }
      return;
    }
    case "object": {
      if (data instanceof Uint8Array) {
        encodeNumWithType(to, BigInt(data.length), TYPE_BYTES);
        for (const c of data) {
          to.push(c);
        }
      } else if (data instanceof Array) {
        encodeNumWithType(to, BigInt(data.length), TYPE_ARR);
        for (const c of data) {
          encodeImpl(to, c);
        }
      } else if (data instanceof Map) {
        encodeMap(to, data);
      } else if (data instanceof Address) {
        to.push(SPECIAL_ADDR);
        for (const c of data.bytes) {
          to.push(c);
        }
      } else if (Object.getPrototypeOf(data) === Object.prototype) {
        encodeMap(to, Object.entries(data));
      } else {
        reportError("unknown object type", data);
      }
      return;
    }
    default:
      reportError("unknown base type", data);
  }
}
function encode(data) {
  const arr = [];
  encodeImpl(arr, data);
  return new Uint8Array(arr);
}
function serialize(data) {
  return toRlp(data.map((param) => toHex(param)));
}
function encodeAndSerialize(data) {
  return serialize([encode(data)]);
}

// src/contracts/actions.ts
var contractActions = (client) => {
  return {
    getContractSchema: async (address) => {
      const schema = await client.request({
        method: "gen_getContractSchema",
        params: [address]
      });
      return schema;
    },
    getContractSchemaForCode: async (contractCode) => {
      const schema = await client.request({
        method: "gen_getContractSchemaForCode",
        params: [contractCode]
      });
      return schema;
    }
  };
};
var overrideContractActions = (client) => {
  client.readContract = async (args) => {
    const { account, address, functionName, args: params } = args;
    const encodedData = encodeAndSerialize({ method: functionName, args: params });
    let senderAddress = account?.address ?? client.account?.address;
    const requestParams = {
      to: address,
      from: senderAddress,
      data: encodedData
    };
    const result = await client.request({
      method: "eth_call",
      params: [requestParams, "latest"]
    });
    if (typeof result === "string") {
      const val = Uint8Array.from(atob(result), (c) => c.charCodeAt(0));
      return decode(val);
    } else {
      return "<unknown>";
    }
  };
  client.writeContract = async (args) => {
    const { account, address, functionName, args: params, value = 0n, leaderOnly = false } = args;
    const data = [encode({ method: functionName, args: params }), leaderOnly];
    const serializedData = serialize(data);
    const senderAccount = account || client.account;
    if (senderAccount?.type !== "local") {
      const transaction = {
        from: senderAccount?.address,
        to: address,
        data: serializedData,
        value: `0x${value.toString(16)}`
      };
      return await client.request({
        method: "eth_sendTransaction",
        params: [transaction]
      });
    }
    if (!senderAccount) {
      throw new Error(
        "No account set. Configure the client with an account or pass an account to this function."
      );
    }
    if (!senderAccount?.signTransaction) {
      throw new Error("Account does not support signTransaction");
    }
    const nonce = await client.getCurrentNonce({ address: senderAccount.address });
    const signedTransaction = await senderAccount.signTransaction({
      data: serializedData,
      to: address,
      value,
      type: "legacy",
      nonce
    });
    return await client.request({
      method: "eth_sendRawTransaction",
      params: [signedTransaction]
    });
  };
  client.deployContract = async (args) => {
    const { account, code, args: constructorArgs, leaderOnly = false } = args;
    const data = [code, encode({ args: constructorArgs }), leaderOnly];
    const serializedData = serialize(data);
    const senderAccount = account || client.account;
    if (senderAccount?.type !== "local") {
      const transaction = {
        from: senderAccount?.address,
        to: null,
        data: serializedData,
        value: "0x0"
      };
      return await client.request({
        method: "eth_sendTransaction",
        params: [transaction]
      });
    }
    if (!senderAccount) {
      throw new Error(
        "No account set. Configure the client with an account or pass an account to this function."
      );
    }
    if (!senderAccount?.signTransaction) {
      throw new Error("Account does not support signTransaction");
    }
    const nonce = await client.getCurrentNonce({ address: senderAccount.address });
    const signedTransaction = await senderAccount.signTransaction({
      data: serializedData,
      type: "legacy",
      nonce
    });
    return await client.request({
      method: "eth_sendRawTransaction",
      params: [signedTransaction]
    });
  };
  return client;
};

// src/config/transactions.ts
var transactionsConfig = {
  waitInterval: 3e3,
  retries: 10
};

// src/utils/async.ts
async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/transactions/actions.ts
var transactionActions = (client) => ({
  waitForTransactionReceipt: async ({
    hash,
    status = "ACCEPTED" /* ACCEPTED */,
    interval = transactionsConfig.waitInterval,
    retries = transactionsConfig.retries
  }) => {
    const transaction = await client.getTransaction({ hash });
    if (!transaction) {
      throw new Error("Transaction not found");
    }
    if (transaction.status === status || status === "ACCEPTED" /* ACCEPTED */ && transaction.status === "FINALIZED" /* FINALIZED */) {
      return transaction;
    }
    if (retries === 0) {
      throw new Error("Transaction status is not " + status);
    }
    await sleep(interval);
    return transactionActions(client).waitForTransactionReceipt({
      hash,
      status,
      interval,
      retries: retries - 1
    });
  }
});

// src/client/client.ts
var createClient = (config = { chain: simulator }) => {
  const chainConfig = config.chain || simulator;
  const rpcUrl = config.endpoint || chainConfig.rpcUrls.default.http[0];
  const isAddress = typeof config.account !== "object";
  const customTransport = {
    async request({ method, params }) {
      if (method.startsWith("eth_") && isAddress) {
        try {
          return await window.ethereum?.request({ method, params });
        } catch (err) {
          console.warn(`Error using window.ethereum for method ${method}:`, err);
          throw err;
        }
      } else {
        try {
          const response = await fetch(rpcUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              jsonrpc: "2.0",
              id: Date.now(),
              method,
              params
            })
          });
          const data = await response.json();
          if (data.error) {
            throw new Error(data.error.message);
          }
          return data.result;
        } catch (err) {
          console.error(`Error fetching ${method} from GenLayer RPC:`, err);
          throw err;
        }
      }
    }
  };
  const baseClient = createViemClient({
    chain: chainConfig,
    transport: custom(customTransport),
    ...config.account ? { account: config.account } : {}
  }).extend(publicActions).extend((client) => accountActions(client)).extend((client) => transactionActions(client)).extend((client) => contractActions(client));
  return overrideContractActions(baseClient);
};

// src/accounts/account.ts
import { generatePrivateKey as _generatePrivateKey, privateKeyToAccount } from "viem/accounts";
var generatePrivateKey = () => _generatePrivateKey();
var createAccount = (accountPrivateKey) => {
  const privateKey = accountPrivateKey || generatePrivateKey();
  const account = privateKeyToAccount(privateKey);
  return account;
};
export {
  chains_exports as chains,
  createAccount,
  createClient,
  generatePrivateKey
};
