import { S as SimulatorChain } from '../chains-BV4Glo-M.js';
import { Client, Transport, PublicActions, Account } from 'viem';
export { Account } from 'viem';

type Address$1 = `0x${string}` & {
    length: 42;
};

declare class Address {
    bytes: Uint8Array;
    constructor(addr: Uint8Array);
}
type CalldataEncodable = null | boolean | Address | number | bigint | string | Uint8Array | Array<CalldataEncodable> | Map<string, CalldataEncodable> | {
    [key: string]: CalldataEncodable;
};
type MethodDescription = {
    method: string;
    args: Array<CalldataEncodable>;
};
type TransactionData = {
    method: string;
    args: CalldataEncodable[];
};

type TransactionHash = `0x${string}` & {
    length: 66;
};
declare enum TransactionStatus {
    PENDING = "PENDING",
    CANCELED = "CANCELED",
    PROPOSING = "PROPOSING",
    COMMITTING = "COMMITTING",
    REVEALING = "REVEALING",
    ACCEPTED = "ACCEPTED",
    FINALIZED = "FINALIZED",
    UNDETERMINED = "UNDETERMINED"
}
type GenLayerTransaction = {
    hash: TransactionHash;
    status: TransactionStatus;
    from_address?: string;
    to_address?: string;
    data?: Record<string, unknown>;
    consensus_data?: {
        final: boolean;
        leader_receipt?: {
            calldata: string;
            class_name: string;
            contract_state: string;
            eq_outputs: Record<string, unknown>;
            error: string | null;
            execution_result: string;
            gas_used: number;
            mode: string;
            node_config: Record<string, unknown>;
            pending_transactions: unknown[];
            vote: string;
        };
        validators?: Record<string, unknown>[];
        votes?: Record<string, string>;
    };
    nonce?: number;
    value?: number;
    type?: number;
    gaslimit?: bigint;
    created_at?: Date;
    r?: number;
    s?: number;
    v?: number;
};
type TransactionDataElement = string | number | bigint | boolean | Uint8Array;

type ContractParamsArraySchemaElement = ContractParamsSchema | {
    $rep: ContractParamsSchema;
};
type ContractParamsSchema = "null" | "bool" | "int" | "address" | "string" | "bytes" | "any" | "array" | "dict" | {
    $or: ContractParamsSchema[];
} | {
    $dict: ContractParamsSchema;
} | {
    [key: string]: ContractParamsSchema;
} | ContractParamsArraySchemaElement[];
interface ContractMethodBase {
    params: [string, ContractParamsSchema][];
    kwparams: {
        [key: string]: ContractParamsSchema;
    };
}
interface ContractMethod extends ContractMethodBase {
    ret: ContractParamsSchema;
    readonly: boolean;
}
type ContractSchema = {
    ctor: ContractMethodBase;
    methods: ContractMethod[];
};

type GenLayerMethod = {
    method: "sim_fundAccount";
    params: [address: string, amount: number];
} | {
    method: "eth_getTransactionByHash";
    params: [hash: TransactionHash];
} | {
    method: "eth_call";
    params: [requestParams: any, blockNumberOrHash: string];
} | {
    method: "eth_sedRawTransaction";
    params: [signedTransaction: string];
} | {
    method: "gen_getContractSchema";
    params: [address: string];
} | {
    method: "gen_getContractSchemaForCode";
    params: [contractCode: string];
} | {
    method: "sim_getTransactionsForAddress";
    params: [address: string, filter?: "all" | "from" | "to"];
} | {
    method: "eth_getTransactionCount";
    params: [address: string, block: string];
};
type GenLayerClient<TSimulatorChain extends SimulatorChain> = Omit<Client<Transport, TSimulatorChain>, "transport" | "getTransaction" | "readContract"> & Omit<PublicActions<Transport, TSimulatorChain>, "readContract" | "getTransaction" | "waitForTransactionReceipt"> & {
    request: Client<Transport, TSimulatorChain>["request"] & {
        <TMethod extends GenLayerMethod>(args: Extract<GenLayerMethod, {
            method: TMethod["method"];
        }>): Promise<unknown>;
    };
    readContract: (args: {
        account?: Account;
        address: Address$1;
        functionName: string;
        args: CalldataEncodable[];
    }) => Promise<unknown>;
    writeContract: (args: {
        account?: Account;
        address: Address$1;
        functionName: string;
        args: CalldataEncodable[];
        value: bigint;
        leaderOnly?: boolean;
    }) => Promise<any>;
    deployContract: (args: {
        account?: Account;
        code: string;
        args: CalldataEncodable[];
        leaderOnly?: boolean;
    }) => Promise<`0x${string}`>;
    getTransaction: (args: {
        hash: TransactionHash;
    }) => Promise<GenLayerTransaction>;
    getCurrentNonce: (args: {
        address: string;
    }) => Promise<number>;
    waitForTransactionReceipt: (args: {
        hash: TransactionHash;
        status?: TransactionStatus;
        interval?: number;
        retries?: number;
    }) => Promise<GenLayerTransaction>;
    getContractSchema: (address: string) => Promise<ContractSchema>;
    getContractSchemaForCode: (contractCode: string) => Promise<ContractSchema>;
};

export { type Address$1 as Address, type CalldataEncodable, type ContractMethod, type ContractMethodBase, type ContractParamsArraySchemaElement, type ContractParamsSchema, type ContractSchema, type GenLayerClient, type GenLayerMethod, type GenLayerTransaction, type MethodDescription, SimulatorChain, type TransactionData, type TransactionDataElement, type TransactionHash, TransactionStatus };
