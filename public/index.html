<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Consensus Gallery | GenLayer Game</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé®</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: { extend: { colors: { primary: { 300: '#a5b4fc', 400: '#818cf8', 500: '#667eea', 600: '#5a67d8' } } } }
    }
  </script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%); min-height: 100vh; font-family: 'Inter', sans-serif; }
    .gradient-text { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .gradient-text-gold { background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .glass { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); }
    .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
    .btn-success { background: linear-gradient(135deg, #10B981 0%, #059669 100%); }
    .btn-warning { background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .pulse-dot { animation: pulse 2s ease-in-out infinite; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .animate-fade-in { animation: fadeIn 0.5s ease-out; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .animate-spin { animation: spin 1s linear infinite; }
    .chat-scroll { max-height: 400px; overflow-y: auto; }
    .chat-scroll::-webkit-scrollbar { width: 6px; }
    .chat-scroll::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    .chat-scroll::-webkit-scrollbar-thumb { background: rgba(102,126,234,0.3); border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    const CONTRACT = {
      ADDRESS: '0x93b8A5b05516ECb9E6a6F10d0b80fe913Aff99BE',
      NETWORK: 'GenLayer Studio',
      CHAIN_ID: '0x' + (61999).toString(16),
      RPC_URL: 'https://rpc.studio.genlayer.com',
    };

    const CONFIG = {
      MAX_PLAYERS: 5,
      MIN_PLAYERS: 2,
      ENTRY_FEE: 0.0000,  // 0.0001 GEN ÂÖ•Âú∫Ë¥π
      WINNER_REWARD_PERCENT: 0,  // ÂéªÊéâÂ•ñÈáëÊ±†ÂàÜÈÖç
      MIN_GAME_DURATION: 30,
      MAX_GAME_DURATION: 3 * 60,
      VOTE_DURATION: 30,
      WINNER_EXP: 100,
      CORRECT_VOTER_EXP: 30,
      PARTICIPANT_EXP: 10,
      ROOM_IDLE_TIMEOUT: 60,
      AI_FILL_DELAY: 30,  // 30ÁßíÊó†‰∫∫Âä†ÂÖ•ÂàôAIÈô™Áé©
      SYNC_INTERVAL: 500,  // Faster sync for better multi-tab experience
    };
    
    // BroadcastChannel for instant cross-tab sync
    const broadcastChannel = typeof BroadcastChannel !== 'undefined' ? new BroadcastChannel('consensus_gallery_sync') : null;

    const AI_PLAYERS = [
      { address: '0xAI00000000000000000000000000000000000001', name: 'ArtBot_Alpha',
        descriptions: ['This artwork captures profound beauty and emotion.', 'The colors blend harmoniously creating a mesmerizing experience.', 'Deep symbolism in every brushstroke of this masterpiece.']},
      { address: '0xAI00000000000000000000000000000000000002', name: 'ArtBot_Beta',
        descriptions: ['The composition draws the eye naturally across the canvas.', 'Light and shadow play together in perfect balance.', 'This piece speaks to the human condition subtly.']},
      { address: '0xAI00000000000000000000000000000000000003', name: 'ArtBot_Gamma',
        descriptions: ['A stunning display of artistic technique and vision.', 'The mood here is both haunting and beautiful.', 'Every element serves a purpose in this crafted work.']},
      { address: '0xAI00000000000000000000000000000000000004', name: 'ArtBot_Delta',
        descriptions: ['The artist masterfully captures the essence of the subject.', 'There is a timeless quality to this remarkable piece.', 'I am moved by the emotional depth expressed here.']},
    ];

    const isAIPlayer = (address) => address && address.startsWith('0xAI');
    const STORAGE_KEY = 'consensus_gallery_data_v2';

    const ART_COLLECTION = [
      { id: 1, name: 'Starry Night', artist: 'Van Gogh', year: 1889, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/800px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg', fallback: 'https://www.moma.org/media/W1siZiIsIjQ2NzUxNyJdLFsicCIsImNvbnZlcnQiLCItcXVhbGl0eSA5MCAtcmVzaXplIDUxMng1MTJcdTAwM2UiXV0.jpg' },
      { id: 2, name: 'Persistence of Memory', artist: 'Dali', year: 1931, url: 'https://uploads4.wikiart.org/images/salvador-dali/the-persistence-of-memory-1931.jpg', fallback: 'https://www.dalipaintings.com/images/paintings/the-persistence-of-memory.jpg' },
      { id: 3, name: 'The Great Wave', artist: 'Hokusai', year: 1831, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Tsunami_by_hokusai_19th_century.jpg/800px-Tsunami_by_hokusai_19th_century.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/0/0a/The_Great_Wave_off_Kanagawa.jpg' },
      { id: 4, name: 'Girl with Pearl Earring', artist: 'Vermeer', year: 1665, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/1665_Girl_with_a_Pearl_Earring.jpg/800px-1665_Girl_with_a_Pearl_Earring.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/d/d7/Meisje_met_de_parel.jpg' },
      { id: 5, name: 'The Scream', artist: 'Munch', year: 1893, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Edvard_Munch%2C_1893%2C_The_Scream%2C_oil%2C_tempera_and_pastel_on_cardboard%2C_91_x_73_cm%2C_National_Gallery_of_Norway.jpg/800px-Edvard_Munch%2C_1893%2C_The_Scream%2C_oil%2C_tempera_and_pastel_on_cardboard%2C_91_x_73_cm%2C_National_Gallery_of_Norway.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/f/f4/The_Scream.jpg' },
      { id: 6, name: 'Birth of Venus', artist: 'Botticelli', year: 1485, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0b/Sandro_Botticelli_-_La_nascita_di_Venere_-_Google_Art_Project_-_edited.jpg/800px-Sandro_Botticelli_-_La_nascita_di_Venere_-_Google_Art_Project_-_edited.jpg', fallback: 'https://www.uffizi.it/immagini/opere/botticelli-venere/botticelli-nascita-venere.jpg' },
      { id: 7, name: 'American Gothic', artist: 'Wood', year: 1930, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Grant_Wood_-_American_Gothic_-_Google_Art_Project.jpg/800px-Grant_Wood_-_American_Gothic_-_Google_Art_Project.jpg', fallback: 'https://www.artic.edu/iiif/2/b272df73-a965-ac37-4172-be4e99483637/full/843,/0/default.jpg' },
      { id: 8, name: 'The Kiss', artist: 'Klimt', year: 1908, url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/The_Kiss_-_Gustav_Klimt_-_Google_Cultural_Institute.jpg/800px-The_Kiss_-_Gustav_Klimt_-_Google_Cultural_Institute.jpg', fallback: 'https://upload.wikimedia.org/wikipedia/commons/f/f3/Gustav_Klimt_016.jpg' },
    ];

    const ADJECTIVES = ['Swift', 'Brave', 'Wise', 'Noble', 'Silent', 'Golden', 'Silver', 'Cosmic', 'Mystic', 'Ancient'];
    const NOUNS = ['Phoenix', 'Dragon', 'Tiger', 'Eagle', 'Wolf', 'Hawk', 'Lion', 'Bear', 'Serpent', 'Falcon'];

    const generatePlayerId = (address) => {
      const aiPlayer = AI_PLAYERS.find(ai => ai.address === address);
      if (aiPlayer) return aiPlayer.name;
      const hash = address.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
      return `${ADJECTIVES[hash % ADJECTIVES.length]}${NOUNS[(hash * 7) % NOUNS.length]}${(hash % 99) + 1}`;
    };

    const shortenAddress = (addr) => addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
    const formatTime = (s) => `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
    const getArt = (id) => ART_COLLECTION.find(a => a.id === id) || ART_COLLECTION[0];
    const getRandomArt = () => ART_COLLECTION[Math.floor(Math.random() * ART_COLLECTION.length)];

    const getStorage = () => { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || null; } catch { return null; } };
    const setStorage = (data) => { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch {} };
    const createInitialState = () => ({ rooms: {}, leaderboard: {}, totalGames: 0, playerIds: {}, gameHistory: [] });

    const cleanupRooms = (state) => {
      const now = Date.now();
      const cleanedRooms = {};
      Object.entries(state.rooms || {}).forEach(([id, room]) => {
        if (room.phase === 'finished') return;
        if (room.phase === 'waiting' && room.players.length === 1 && (now - room.createdAt) > CONFIG.ROOM_IDLE_TIMEOUT * 1000) return;
        cleanedRooms[id] = room;
      });
      return { ...state, rooms: cleanedRooms };
    };

    // Merge room states for sync - keep the most up-to-date version
    const mergeRoomStates = (localState, remoteState) => {
      const mergedRooms = { ...localState.rooms };
      
      Object.entries(remoteState.rooms || {}).forEach(([id, remoteRoom]) => {
        const localRoom = mergedRooms[id];
        
        if (!localRoom) {
          // New room from remote
          mergedRooms[id] = remoteRoom;
        } else {
          // Merge: prefer room with more players or later phase
          const phaseOrder = { waiting: 0, playing: 1, voting: 2, finished: 3 };
          const localPhase = phaseOrder[localRoom.phase] || 0;
          const remotePhase = phaseOrder[remoteRoom.phase] || 0;
          
          if (remotePhase > localPhase) {
            // Remote is more advanced
            mergedRooms[id] = remoteRoom;
          } else if (remotePhase === localPhase) {
            // Same phase - merge players and messages
            const mergedPlayers = [...new Set([...localRoom.players, ...remoteRoom.players])];
            const mergedMessages = [...localRoom.messages];
            remoteRoom.messages.forEach(rm => {
              if (!mergedMessages.find(lm => lm.id === rm.id)) {
                mergedMessages.push(rm);
              }
            });
            mergedMessages.sort((a, b) => a.timestamp - b.timestamp);
            
            const mergedVotes = { ...localRoom.votes, ...remoteRoom.votes };
            const mergedEndVotes = [...new Set([...(localRoom.endGameVotes || []), ...(remoteRoom.endGameVotes || [])])];
            
            mergedRooms[id] = {
              ...localRoom,
              ...remoteRoom,
              players: mergedPlayers,
              messages: mergedMessages,
              votes: mergedVotes,
              endGameVotes: mergedEndVotes,
              pool: Math.max(localRoom.pool || 0, remoteRoom.pool || 0),
            };
          }
        }
      });
      
      return {
        ...localState,
        rooms: mergedRooms,
        leaderboard: { ...localState.leaderboard, ...remoteState.leaderboard },
        gameHistory: [...new Set([...(localState.gameHistory || []), ...(remoteState.gameHistory || [])])].slice(-100),
        totalGames: Math.max(localState.totalGames || 0, remoteState.totalGames || 0),
        playerIds: { ...localState.playerIds, ...remoteState.playerIds },
      };
    };

    const phaseLabels = { waiting: 'Waiting', playing: 'Playing', voting: 'Voting', finished: 'Finished' };
    const phaseColors = { waiting: '#6B7280', playing: '#10B981', voting: '#F59E0B', finished: '#8B5CF6' };
    const Spinner = () => <div className="inline-block w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>;

    const ArtDisplay = ({ artId, size = 280 }) => {
      const art = getArt(artId);
      const [loaded, setLoaded] = useState(false);
      const [error, setError] = useState(false);
      const [imgSrc, setImgSrc] = useState(art.url);
      const handleError = () => { if (!error && art.fallback) { setError(true); setImgSrc(art.fallback); } };
      return (
        <div className="relative flex-shrink-0" style={{ width: size, height: size }}>
          {!loaded && <div className="absolute inset-0 flex items-center justify-center bg-white/5 rounded-xl"><Spinner /></div>}
          <img src={imgSrc} alt={art.name} onLoad={() => setLoaded(true)} onError={handleError} crossOrigin="anonymous"
            className={`w-full h-full object-cover rounded-xl shadow-xl transition-opacity ${loaded ? 'opacity-100' : 'opacity-0'}`} />
          {size > 80 && (
            <div className="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent rounded-b-xl">
              <div className="text-sm font-medium text-white truncate">{art.name}</div>
              <div className="text-xs text-gray-300 truncate">{art.artist}, {art.year}</div>
            </div>
          )}
        </div>
      );
    };

    // Game Rules Component
    const GameRules = ({ showRules, setShowRules }) => {
      if (!showRules) return null;
      return (
        <div className="fixed inset-0 bg-black/70 z-50 flex items-center justify-center p-4" onClick={() => setShowRules(false)}>
          <div className="glass rounded-2xl p-6 max-w-lg w-full max-h-[80vh] overflow-y-auto animate-fade-in" onClick={e => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-bold gradient-text">üìú Game Rules</h3>
              <button onClick={() => setShowRules(false)} className="text-gray-400 hover:text-white text-xl">‚úï</button>
            </div>
            <div className="space-y-4 text-sm text-gray-300">
              <div className="p-3 bg-white/5 rounded-lg">
                <h4 className="font-semibold text-white mb-2">üéÆ How to Play</h4>
                <ol className="list-decimal list-inside space-y-1">
                  <li>Connect your MetaMask wallet</li>
                  <li>Create a new room or join an existing one</li>
                  <li>Wait for other players (or AI bots join after {CONFIG.AI_FILL_DELAY}s)</li>
                  <li>Host starts the game when ready (min 2 players)</li>
                </ol>
              </div>
              <div className="p-3 bg-white/5 rounded-lg">
                <h4 className="font-semibold text-white mb-2">üé® Gameplay</h4>
                <ol className="list-decimal list-inside space-y-1">
                  <li>View the artwork displayed</li>
                  <li>Write creative descriptions of the art ({CONFIG.MAX_GAME_DURATION / 60} minutes)</li>
                  <li>After time ends, vote for the best description</li>
                  <li>Most voted player wins!</li>
                </ol>
              </div>
              <div className="p-3 bg-white/5 rounded-lg">
                <h4 className="font-semibold text-white mb-2">‚≠ê XP Rewards</h4>
                <ul className="space-y-1">
                  <li>üèÜ <span className="text-yellow-400">Win the game:</span> +{CONFIG.WINNER_EXP} XP</li>
                  <li>‚úì <span className="text-green-400">Vote for winner:</span> +{CONFIG.CORRECT_VOTER_EXP} XP</li>
                  <li>üë§ <span className="text-blue-400">Participate:</span> +{CONFIG.PARTICIPANT_EXP} XP</li>
                </ul>
              </div>
              <div className="p-3 bg-white/5 rounded-lg">
                <h4 className="font-semibold text-white mb-2">üí∞ Entry Fee</h4>
                <ul className="space-y-1">
                  <li>‚Ä¢ Create/Join room costs <span className="text-yellow-400">{CONFIG.ENTRY_FEE} GEN</span></li>
                  <li>‚Ä¢ Fee is sent to contract on-chain</li>
                </ul>
              </div>
              <div className="p-3 bg-white/5 rounded-lg">
                <h4 className="font-semibold text-white mb-2">‚ö†Ô∏è Important</h4>
                <ul className="space-y-1">
                  <li>‚Ä¢ Room closes if empty for 60 seconds</li>
                  <li>‚Ä¢ Cannot join after game starts</li>
                  <li>‚Ä¢ AI players auto-join if no one joins</li>
                  <li>‚Ä¢ Vote time: {CONFIG.VOTE_DURATION} seconds</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      );
    };

    function App() {
      const [wallet, setWallet] = useState({ connected: false, address: '' });
      const [globalState, setGlobalState] = useState(() => {
        const stored = getStorage();
        return stored ? cleanupRooms({ ...createInitialState(), ...stored }) : createInitialState();
      });
      const [activeTab, setActiveTab] = useState('lobby');
      const [currentRoomId, setCurrentRoomId] = useState(null);
      const [message, setMessage] = useState('');
      const [error, setError] = useState('');
      const [success, setSuccess] = useState('');
      const [processing, setProcessing] = useState(false);
      const [timeLeft, setTimeLeft] = useState(0);
      const [lastFinishedGameId, setLastFinishedGameId] = useState(null);
      const [showRules, setShowRules] = useState(false);
      
      const globalStateRef = useRef(globalState);
      globalStateRef.current = globalState;
      const currentRoomIdRef = useRef(currentRoomId);
      currentRoomIdRef.current = currentRoomId;
      const chatEndRef = useRef(null);
      const currentRoom = currentRoomId ? globalState.rooms[currentRoomId] : null;

      const getPlayerId = useCallback((address) => {
        if (!address) return '';
        if (globalState.playerIds[address]) return globalState.playerIds[address];
        const newId = generatePlayerId(address);
        setGlobalState(prev => ({ ...prev, playerIds: { ...prev.playerIds, [address]: newId } }));
        return newId;
      }, [globalState.playerIds]);

      // Save to localStorage and broadcast to other tabs
      useEffect(() => { 
        setStorage(globalState);
        // Broadcast to other tabs for instant sync
        if (broadcastChannel) {
          try {
            broadcastChannel.postMessage({ type: 'state_update', state: globalState });
          } catch (e) {}
        }
      }, [globalState]);
      
      // Cross-tab sync with BroadcastChannel and localStorage
      useEffect(() => {
        // Listen for BroadcastChannel messages (instant)
        const handleBroadcast = (e) => {
          if (e.data && e.data.type === 'state_update' && e.data.state) {
            setGlobalState(prev => cleanupRooms(mergeRoomStates(prev, e.data.state)));
          }
        };
        if (broadcastChannel) {
          broadcastChannel.onmessage = handleBroadcast;
        }
        
        // Listen for localStorage changes (backup)
        const handleStorage = (e) => {
          if (e.key === STORAGE_KEY && e.newValue) {
            try { 
              const remoteState = JSON.parse(e.newValue);
              setGlobalState(prev => cleanupRooms(mergeRoomStates(prev, remoteState)));
            } catch {}
          }
        };
        window.addEventListener('storage', handleStorage);
        
        // Periodic sync as fallback
        const syncInterval = setInterval(() => {
          const stored = getStorage();
          if (stored) {
            setGlobalState(prev => {
              const merged = cleanupRooms(mergeRoomStates(prev, stored));
              if (JSON.stringify(prev) !== JSON.stringify(merged)) {
                return merged;
              }
              return prev;
            });
          }
        }, CONFIG.SYNC_INTERVAL);
        
        return () => { 
          window.removeEventListener('storage', handleStorage); 
          clearInterval(syncInterval);
          if (broadcastChannel) broadcastChannel.onmessage = null;
        };
      }, []);

      // Game timer
      useEffect(() => {
        const timer = setInterval(() => {
          const roomId = currentRoomIdRef.current;
          if (!roomId) return;
          const room = globalStateRef.current.rooms[roomId];
          if (!room || room.phase === 'finished' || room.phase === 'waiting') { setTimeLeft(0); return; }
          const now = Date.now();
          const elapsed = Math.floor((now - room.startTime) / 1000);
          const remaining = room.phase === 'voting' ? Math.max(0, Math.floor((room.voteDeadline - now) / 1000)) : CONFIG.MAX_GAME_DURATION - elapsed;
          setTimeLeft(Math.max(0, remaining));
          if (room.phase === 'playing' && elapsed >= CONFIG.MAX_GAME_DURATION) handleStartVoting(roomId);
          else if (room.phase === 'voting' && remaining <= 0) handleFinalizeGame(roomId);
        }, 1000);
        return () => clearInterval(timer);
      }, []);

      useEffect(() => { if (chatEndRef.current) chatEndRef.current.scrollIntoView({ behavior: 'smooth' }); }, [currentRoom?.messages?.length]);

      const connectWallet = async () => {
        if (typeof window.ethereum === 'undefined') { setError('Please install MetaMask!'); setTimeout(() => setError(''), 4000); return; }
        setProcessing(true);
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          if (accounts && accounts.length > 0) {
            setWallet({ connected: true, address: accounts[0] });
            getPlayerId(accounts[0]);
            setSuccess('Wallet Connected!');
            setTimeout(() => setSuccess(''), 3000);
          }
        } catch (err) { setError('Failed to connect wallet'); setTimeout(() => setError(''), 4000); }
        setProcessing(false);
      };

      // Auto-reconnect wallet on page load
      useEffect(() => {
        const autoConnect = async () => {
          if (typeof window.ethereum !== 'undefined') {
            try {
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              if (accounts && accounts.length > 0) {
                setWallet({ connected: true, address: accounts[0] });
                getPlayerId(accounts[0]);
              }
            } catch (err) {
              console.log('Auto-connect failed:', err);
            }
          }
        };
        autoConnect();
      }, []);

      // Listen for account changes
      useEffect(() => {
        if (typeof window.ethereum !== 'undefined') {
          const handler = (accounts) => {
            if (accounts.length === 0) setWallet({ connected: false, address: '' });
            else { setWallet({ connected: true, address: accounts[0] }); getPlayerId(accounts[0]); }
          };
          window.ethereum.on('accountsChanged', handler);
          return () => window.ethereum.removeListener('accountsChanged', handler);
        }
      }, []);

      // Send transaction - skip if amount is 0 to avoid RPC errors
      const sendTransaction = async (toAddress, amountInEth, fromAddress) => {
        // Skip transaction if amount is 0
        if (amountInEth <= 0) {
          console.log('Skipping transaction - amount is 0');
          return 'skipped';
        }
        
        if (!window.ethereum) throw new Error('MetaMask not found');
        const from = fromAddress || wallet.address || (await window.ethereum.request({ method: 'eth_accounts' }))[0];
        if (!from) throw new Error('No wallet address');
        const amountWei = '0x' + Math.floor(amountInEth * 1e18).toString(16);
        return await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from, to: toAddress, value: amountWei }] });
      };

      const handleCreateRoom = async () => {
        let currentAddress = wallet.address;
        
        // Auto-connect wallet if not connected
        if (!wallet.connected || !currentAddress) {
          if (typeof window.ethereum === 'undefined') { 
            setError('Please install MetaMask!'); 
            setTimeout(() => setError(''), 4000); 
            return; 
          }
          setProcessing(true);
          try {
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (accounts && accounts.length > 0) {
              currentAddress = accounts[0];
              setWallet({ connected: true, address: currentAddress });
              getPlayerId(currentAddress);
            } else {
              setError('Failed to connect wallet');
              setTimeout(() => setError(''), 4000);
              setProcessing(false);
              return;
            }
          } catch (err) {
            setError('Wallet connection cancelled');
            setTimeout(() => setError(''), 4000);
            setProcessing(false);
            return;
          }
        } else {
          setProcessing(true);
        }
        
        let newRoomId = null;
        try {
          if (!currentAddress) { setError('No wallet address'); setProcessing(false); return; }
          
          // Only send transaction if entry fee > 0
          if (CONFIG.ENTRY_FEE > 0) {
            await sendTransaction(CONTRACT.ADDRESS, CONFIG.ENTRY_FEE, currentAddress);
          }
          
          const art = getRandomArt();
          newRoomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
          const room = { id: newRoomId, gameNumber: globalState.totalGames + 1, creator: currentAddress, phase: 'waiting', artId: art.id, artName: art.name, maxPlayers: CONFIG.MAX_PLAYERS, players: [currentAddress], pool: CONFIG.ENTRY_FEE, messages: [], votes: {}, endGameVotes: [], winner: null, createdAt: Date.now(), startTime: null, voteDeadline: null, locked: false };
          setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [newRoomId]: room }, totalGames: prev.totalGames + 1 }));
          setCurrentRoomId(newRoomId);
          setActiveTab('game');
          setSuccess('Room Created!');
          setTimeout(() => setSuccess(''), 3000);
        } catch (err) { 
          console.error('Create room error:', err);
          setError(err.code === 4001 ? 'Transaction cancelled' : 'Failed to create room: ' + (err.message || '')); 
          setTimeout(() => setError(''), 4000); 
          setProcessing(false); 
          return; 
        }
        setProcessing(false);
        if (newRoomId) {
          setTimeout(() => {
            setGlobalState(prev => {
              const room = prev.rooms[newRoomId];
              if (!room || room.phase !== 'waiting' || room.players.length > 1) return prev;
              return { ...prev, rooms: { ...prev.rooms, [newRoomId]: { ...room, players: [...room.players, ...AI_PLAYERS.map(ai => ai.address)] } } };
            });
          }, CONFIG.AI_FILL_DELAY * 1000);
        }
      };

      const handleJoinRoom = async (roomId) => {
        let currentAddress = wallet.address;
        
        // Auto-connect wallet if not connected
        if (!wallet.connected || !currentAddress) {
          if (typeof window.ethereum === 'undefined') { 
            setError('Please install MetaMask!'); 
            setTimeout(() => setError(''), 4000); 
            return; 
          }
          setProcessing(true);
          try {
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (accounts && accounts.length > 0) {
              currentAddress = accounts[0];
              setWallet({ connected: true, address: currentAddress });
              getPlayerId(currentAddress);
            } else {
              setError('Failed to connect wallet');
              setTimeout(() => setError(''), 4000);
              setProcessing(false);
              return;
            }
          } catch (err) {
            setError('Wallet connection cancelled');
            setTimeout(() => setError(''), 4000);
            setProcessing(false);
            return;
          }
        } else {
          setProcessing(true);
        }
        
        if (!currentAddress) { setError('No wallet address'); setProcessing(false); return; }
        
        // Re-check room state from storage for latest data
        const latestState = getStorage();
        const room = latestState?.rooms?.[roomId] || globalState.rooms[roomId];
        
        if (!room) { setError('Room not found'); setTimeout(() => setError(''), 3000); setProcessing(false); return; }
        if (room.phase !== 'waiting') { setError('Game already started - cannot join'); setTimeout(() => setError(''), 3000); setProcessing(false); return; }
        if (room.locked) { setError('Room is locked'); setTimeout(() => setError(''), 3000); setProcessing(false); return; }
        if (room.players.length >= room.maxPlayers) { setError('Room is full'); setTimeout(() => setError(''), 3000); setProcessing(false); return; }
        if (room.players.includes(currentAddress)) { setCurrentRoomId(roomId); setActiveTab('game'); setProcessing(false); return; }
        
        try {
          // Only send transaction if entry fee > 0
          if (CONFIG.ENTRY_FEE > 0) {
            await sendTransaction(CONTRACT.ADDRESS, CONFIG.ENTRY_FEE, currentAddress);
          }
          setGlobalState(prev => {
            const r = prev.rooms[roomId];
            if (!r || r.phase !== 'waiting' || r.locked) return prev;
            if (r.players.includes(currentAddress)) return prev;
            return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...r, players: [...r.players, currentAddress], pool: (r.pool || 0) + CONFIG.ENTRY_FEE } } };
          });
          setCurrentRoomId(roomId);
          setActiveTab('game');
          setSuccess('Joined Room!');
          setTimeout(() => setSuccess(''), 3000);
        } catch (err) { 
          console.error('Join room error:', err);
          setError(err.code === 4001 ? 'Transaction cancelled' : 'Failed to join: ' + (err.message || '')); 
          setTimeout(() => setError(''), 4000); 
        }
        setProcessing(false);
      };

      const handleStartGame = (roomId) => {
        const room = globalState.rooms[roomId];
        if (!room || room.phase !== 'waiting' || room.players.length < CONFIG.MIN_PLAYERS) return;
        
        // Lock room and start game
        setGlobalState(prev => ({ 
          ...prev, 
          rooms: { 
            ...prev.rooms, 
            [roomId]: { 
              ...prev.rooms[roomId], 
              phase: 'playing', 
              locked: true, 
              startTime: Date.now() 
            } 
          } 
        }));
        
        // AI players send messages
        room.players.filter(isAIPlayer).forEach((aiAddr, idx) => {
          const ai = AI_PLAYERS.find(a => a.address === aiAddr);
          if (!ai) return;
          setTimeout(() => {
            setGlobalState(prev => {
              const r = prev.rooms[roomId];
              if (!r || r.phase !== 'playing') return prev;
              return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...r, messages: [...r.messages, { id: Date.now() + idx, author: aiAddr, content: ai.descriptions[Math.floor(Math.random() * ai.descriptions.length)], timestamp: Date.now() }] } } };
            });
          }, 5000 + Math.random() * 25000 + idx * 3000);
        });
      };

      const handleSendMessage = () => {
        if (!wallet.connected || !currentRoomId || !message.trim()) return;
        const room = globalState.rooms[currentRoomId];
        if (!room || room.phase !== 'playing') return;
        setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [currentRoomId]: { ...room, messages: [...room.messages, { id: Date.now(), author: wallet.address, content: message.trim(), timestamp: Date.now() }] } } }));
        setMessage('');
      };

      const handleVoteEndGame = () => {
        if (!wallet.connected || !currentRoomId) return;
        const room = globalState.rooms[currentRoomId];
        if (!room || room.phase !== 'playing' || (Date.now() - room.startTime) / 1000 < CONFIG.MIN_GAME_DURATION || room.endGameVotes.includes(wallet.address)) return;
        const newVotes = [...room.endGameVotes, wallet.address];
        const shouldEnd = newVotes.length >= Math.ceil(room.players.length / 2);
        setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [currentRoomId]: { ...room, endGameVotes: newVotes, ...(shouldEnd ? { phase: 'voting', voteDeadline: Date.now() + CONFIG.VOTE_DURATION * 1000 } : {}) } } }));
      };

      const handleStartVoting = (roomId) => {
        setGlobalState(prev => {
          const room = prev.rooms[roomId];
          if (!room || room.phase !== 'playing') return prev;
          return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...room, phase: 'voting', voteDeadline: Date.now() + CONFIG.VOTE_DURATION * 1000 } } };
        });
        setTimeout(() => {
          setGlobalState(prev => {
            const room = prev.rooms[roomId];
            if (!room || room.phase !== 'voting') return prev;
            const authors = [...new Set(room.messages.map(m => m.author))];
            const humans = authors.filter(a => !isAIPlayer(a));
            const newVotes = { ...room.votes };
            room.players.filter(isAIPlayer).forEach(ai => {
              if (!newVotes[ai] && authors.includes(ai)) {
                newVotes[ai] = humans.length > 0 ? humans[Math.floor(Math.random() * humans.length)] : authors[Math.floor(Math.random() * authors.length)];
              }
            });
            return { ...prev, rooms: { ...prev.rooms, [roomId]: { ...room, votes: newVotes } } };
          });
        }, 3000);
      };

      const handleVote = (targetAddress) => {
        if (!wallet.connected || !currentRoomId) return;
        const room = globalState.rooms[currentRoomId];
        if (!room || room.phase !== 'voting' || room.votes[wallet.address]) { setError('Already voted'); setTimeout(() => setError(''), 3000); return; }
        const newVotes = { ...room.votes, [wallet.address]: targetAddress };
        const authors = [...new Set(room.messages.map(m => m.author))];
        if (authors.every(p => newVotes[p])) setGlobalState(prev => finalizeGameState(prev, currentRoomId, newVotes));
        else setGlobalState(prev => ({ ...prev, rooms: { ...prev.rooms, [currentRoomId]: { ...room, votes: newVotes } } }));
      };

      const handleFinalizeGame = (roomId) => {
        setGlobalState(prev => {
          const room = prev.rooms[roomId];
          if (!room || room.phase === 'finished') return prev;
          return finalizeGameState(prev, roomId, room.votes || {});
        });
      };

      const finalizeGameState = (prevState, roomId, votes) => {
        const room = prevState.rooms[roomId];
        if (!room || room.phase === 'finished') return prevState;
        const authors = [...new Set(room.messages.map(m => m.author))];
        if (authors.length === 0) { const newRooms = { ...prevState.rooms }; delete newRooms[roomId]; return { ...prevState, rooms: newRooms }; }
        const voteCount = {}; authors.forEach(addr => { voteCount[addr] = 0; });
        Object.values(votes).forEach(target => { if (voteCount[target] !== undefined) voteCount[target]++; });
        const maxVotes = Math.max(...Object.values(voteCount), 0);
        const winners = authors.filter(addr => voteCount[addr] === maxVotes);
        const winnerAddress = winners[Math.floor(Math.random() * winners.length)];
        const pool = room.pool || (room.players.length * CONFIG.ENTRY_FEE);
        const winnerReward = pool * (CONFIG.WINNER_REWARD_PERCENT / 100);
        const newLeaderboard = JSON.parse(JSON.stringify(prevState.leaderboard));
        
        // ËÆ∞ÂΩïÊØè‰∏™Áé©ÂÆ∂ÁöÑXPÊòéÁªÜ
        const xpDetails = {};
        
        if (!newLeaderboard[winnerAddress]) newLeaderboard[winnerAddress] = { experience: 0, wins: 0, participations: 0, totalRewards: 0 };
        newLeaderboard[winnerAddress].experience += CONFIG.WINNER_EXP;
        newLeaderboard[winnerAddress].wins += 1;
        newLeaderboard[winnerAddress].totalRewards = (newLeaderboard[winnerAddress].totalRewards || 0) + winnerReward;
        xpDetails[winnerAddress] = { winner: CONFIG.WINNER_EXP, vote: 0, participate: 0, total: CONFIG.WINNER_EXP };
        
        Object.entries(votes).forEach(([voter, target]) => {
          if (isAIPlayer(voter)) return;
          if (!newLeaderboard[voter]) newLeaderboard[voter] = { experience: 0, wins: 0, participations: 0, totalRewards: 0 };
          const voteXP = target === winnerAddress ? CONFIG.CORRECT_VOTER_EXP : CONFIG.PARTICIPANT_EXP;
          newLeaderboard[voter].experience += voteXP;
          newLeaderboard[voter].participations += 1;
          if (!xpDetails[voter]) xpDetails[voter] = { winner: 0, vote: 0, participate: 0, total: 0 };
          if (target === winnerAddress) {
            xpDetails[voter].vote = CONFIG.CORRECT_VOTER_EXP;
          } else {
            xpDetails[voter].participate = CONFIG.PARTICIPANT_EXP;
          }
          xpDetails[voter].total = (xpDetails[voter].winner || 0) + (xpDetails[voter].vote || 0) + (xpDetails[voter].participate || 0);
        });
        
        authors.filter(a => !isAIPlayer(a) && !votes[a]).forEach(addr => {
          if (!newLeaderboard[addr]) newLeaderboard[addr] = { experience: 0, wins: 0, participations: 0, totalRewards: 0 };
          newLeaderboard[addr].participations += 1;
          newLeaderboard[addr].experience += CONFIG.PARTICIPANT_EXP;
          if (!xpDetails[addr]) xpDetails[addr] = { winner: 0, vote: 0, participate: CONFIG.PARTICIPANT_EXP, total: CONFIG.PARTICIPANT_EXP };
        });
        
        const gameRecord = { id: roomId, gameNumber: room.gameNumber, artId: room.artId, artName: room.artName, players: room.players.filter(p => !isAIPlayer(p)), winner: winnerAddress, winnerReward, voteCount, votes, xpDetails, finishedAt: Date.now() };
        const gameHistory = [...(prevState.gameHistory || []), gameRecord].slice(-100);
        
        // Stay on game page to show results - no redirect
        
        return { ...prevState, leaderboard: newLeaderboard, gameHistory, rooms: { ...prevState.rooms, [roomId]: { ...room, phase: 'finished', votes, winner: winnerAddress, voteCount, winnerReward, xpDetails } } };
      };

      const handleLeaveRoom = () => { setCurrentRoomId(null); setActiveTab('lobby'); setMessage(''); };

      const availableRooms = useMemo(() => {
        const now = Date.now();
        return Object.values(globalState.rooms).filter(r => 
          r.phase === 'waiting' && 
          !r.locked && 
          r.players.length < r.maxPlayers && 
          !(r.players.length === 1 && (now - r.createdAt) > CONFIG.ROOM_IDLE_TIMEOUT * 1000)
        );
      }, [globalState.rooms]);
      
      const myRooms = useMemo(() => Object.values(globalState.rooms).filter(r => wallet.connected && r.players.includes(wallet.address) && r.phase !== 'finished'), [globalState.rooms, wallet]);
      const myGameHistory = useMemo(() => !wallet.connected ? [] : (globalState.gameHistory || []).filter(g => g.players.includes(wallet.address)).reverse().slice(0, 50), [globalState.gameHistory, wallet]);
      const sortedLeaderboard = useMemo(() => Object.entries(globalState.leaderboard).filter(([addr]) => !isAIPlayer(addr)).map(([address, stats]) => ({ address, playerId: globalState.playerIds[address] || generatePlayerId(address), experience: stats.experience || 0, wins: stats.wins || 0, participations: stats.participations || 0, totalRewards: stats.totalRewards || 0 })).sort((a, b) => b.experience - a.experience || b.wins - a.wins), [globalState.leaderboard, globalState.playerIds]);

      const gameElapsed = currentRoom?.startTime ? Math.floor((Date.now() - currentRoom.startTime) / 1000) : 0;
      const canVoteEnd = currentRoom?.phase === 'playing' && gameElapsed >= CONFIG.MIN_GAME_DURATION;
      const endVoteProgress = currentRoom ? `${currentRoom.endGameVotes?.length || 0}/${Math.ceil(currentRoom.players.length / 2)}` : '';
      const myPlayerId = wallet.connected ? (globalState.playerIds[wallet.address] || generatePlayerId(wallet.address)) : '';
      const myStats = wallet.connected ? (globalState.leaderboard[wallet.address] || { experience: 0, totalRewards: 0 }) : { experience: 0, totalRewards: 0 };

      return (
        <div className="min-h-screen text-gray-200">
          <GameRules showRules={showRules} setShowRules={setShowRules} />
          
          <header className="flex justify-between items-center px-4 md:px-6 py-4 border-b border-white/10">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-xl flex items-center justify-center text-xl btn-primary">üé®</div>
              <h1 className="text-lg md:text-xl font-bold gradient-text">Consensus Gallery</h1>
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => setShowRules(true)} className="px-3 py-2 glass rounded-lg text-sm hover:bg-white/10 transition">üìú Rules</button>
              {wallet.connected ? (
                <div className="flex items-center gap-2 px-3 py-2 glass rounded-xl">
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  <span className="text-xs md:text-sm font-medium">{myPlayerId}</span>
                  <span className="px-2 py-0.5 bg-primary-500/30 rounded text-xs font-bold text-primary-300">{myStats.experience || 0} XP</span>
                  <span className="text-xs text-gray-400 font-mono">{shortenAddress(wallet.address)}</span>
                </div>
              ) : (
                <button onClick={connectWallet} disabled={processing} className="btn-primary px-4 py-2 rounded-xl text-white text-sm font-semibold flex items-center gap-2">
                  {processing ? <><Spinner /> Connecting...</> : 'ü¶ä Connect'}
                </button>
              )}
            </div>
          </header>

          {error && <div className="fixed top-20 left-1/2 -translate-x-1/2 z-50 px-4 py-3 bg-red-500/90 text-white rounded-lg shadow-lg animate-fade-in flex items-center gap-3 max-w-md"><span className="text-sm">{error}</span><button onClick={() => setError('')} className="ml-2">‚úï</button></div>}
          {success && <div className="fixed top-20 left-1/2 -translate-x-1/2 z-50 px-4 py-3 bg-green-500/90 text-white rounded-lg shadow-lg animate-fade-in">‚úì {success}</div>}

          <nav className="flex gap-1 px-4 md:px-6 py-3 border-b border-white/5 overflow-x-auto">
            {[{ id: 'lobby', icon: 'üè†', label: 'Lobby' }, { id: 'game', icon: 'üéÆ', label: 'Game', badge: myRooms.length > 0 ? myRooms.length : null }, { id: 'history', icon: 'üìú', label: 'History' }, { id: 'leaderboard', icon: 'üèÜ', label: 'Rankings' }].map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)} className={`px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-1.5 whitespace-nowrap ${activeTab === tab.id ? 'bg-primary-500/20 border border-primary-500/50 text-primary-300' : 'text-gray-400 hover:bg-white/5'}`}>
                <span>{tab.icon}</span><span className="hidden sm:inline">{tab.label}</span>
                {tab.badge && <span className="px-1.5 py-0.5 text-xs bg-red-500 text-white rounded-full">{tab.badge}</span>}
              </button>
            ))}
          </nav>

          <main className="px-4 md:px-6 py-6 max-w-6xl mx-auto">
            {activeTab === 'lobby' && (
              <div className="space-y-6 animate-fade-in">
                <div className="text-center py-6">
                  <h2 className="text-2xl md:text-3xl font-bold gradient-text mb-2">Consensus Gallery</h2>
                  <p className="text-gray-400 mb-2">Art Description Game on GenLayer</p>
                  <button onClick={() => setShowRules(true)} className="text-sm text-primary-400 hover:underline">üìú View Game Rules</button>
                </div>
                
                {/* Quick Rules */}
                <div className="glass rounded-2xl p-4">
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-center text-xs">
                    <div className="p-2 bg-white/5 rounded-lg"><div className="text-lg mb-1">üèÜ</div><div className="text-yellow-400 font-bold">+{CONFIG.WINNER_EXP} XP</div><div className="text-gray-500">Win Game</div></div>
                    <div className="p-2 bg-white/5 rounded-lg"><div className="text-lg mb-1">‚úì</div><div className="text-green-400 font-bold">+{CONFIG.CORRECT_VOTER_EXP} XP</div><div className="text-gray-500">Correct Vote</div></div>
                    <div className="p-2 bg-white/5 rounded-lg"><div className="text-lg mb-1">‚è±Ô∏è</div><div className="text-blue-400 font-bold">{CONFIG.MAX_GAME_DURATION / 60} min</div><div className="text-gray-500">Game Time</div></div>
                    <div className="p-2 bg-white/5 rounded-lg"><div className="text-lg mb-1">üë•</div><div className="text-purple-400 font-bold">{CONFIG.MIN_PLAYERS}-{CONFIG.MAX_PLAYERS}</div><div className="text-gray-500">Players</div></div>
                  </div>
                </div>
                
                {/* Create Game - always visible */}
                <div className="glass rounded-2xl p-6">
                  <h3 className="text-lg font-semibold mb-2">üéÆ Create New Game</h3>
                  <p className="text-sm text-gray-400 mb-4">Entry: {CONFIG.ENTRY_FEE} GEN | Game: {CONFIG.MAX_GAME_DURATION / 60}min | Vote: {CONFIG.VOTE_DURATION}s</p>
                  <button onClick={handleCreateRoom} disabled={processing} className="btn-primary w-full py-4 rounded-xl font-semibold flex items-center justify-center gap-2 text-white">
                    {processing ? <><Spinner /> Processing...</> : wallet.connected ? '‚ú® Create Room' : 'ü¶ä Connect & Create Room'}
                  </button>
                </div>

                {/* Available Rooms - always visible */}
                <div className="glass rounded-2xl p-6">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-lg font-semibold">üö™ Available Rooms ({availableRooms.length})</h3>
                    <span className="text-xs text-yellow-500 bg-yellow-500/10 px-2 py-1 rounded">Demo Mode - Same Browser Only</span>
                  </div>
                  <p className="text-xs text-gray-500 mb-4">üí° To test multi-player: Open this page in multiple browser tabs</p>
                  {availableRooms.length === 0 ? <div className="text-center py-8 text-gray-500">No rooms available. Create one!</div> : (
                    <div className="space-y-3">
                      {availableRooms.map(room => (
                        <div key={room.id} className="flex items-center justify-between p-4 bg-white/5 rounded-xl hover:bg-white/10 transition">
                          <div className="flex items-center gap-4">
                            <ArtDisplay artId={room.artId} size={60} />
                            <div>
                              <div className="font-medium">{room.artName}</div>
                              <div className="text-sm text-gray-400">üë• {room.players?.length || 0}/{room.maxPlayers} | Host: {globalState.playerIds[room.creator] || generatePlayerId(room.creator)}</div>
                              <div className="text-xs text-gray-500">Status: {room.locked ? 'üîí Locked' : 'üü¢ Open'}</div>
                            </div>
                          </div>
                          <button onClick={() => handleJoinRoom(room.id)} disabled={processing || room.locked} className={`px-4 py-2 rounded-lg text-white text-sm font-medium ${room.locked ? 'bg-gray-500 cursor-not-allowed' : 'btn-success'}`}>
                            {processing ? <Spinner /> : room.locked ? 'Locked' : wallet.connected ? 'Join' : 'Connect & Join'}
                          </button>
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                {/* My Games - only when connected */}
                {wallet.connected && myRooms.length > 0 && (
                  <div className="glass rounded-2xl p-6 border-primary-500/30">
                    <h3 className="text-lg font-semibold mb-4 text-primary-300">‚è≥ My Games</h3>
                    <div className="space-y-3">
                      {myRooms.map(room => (
                        <div key={room.id} className="flex items-center justify-between p-4 bg-primary-500/10 rounded-xl">
                          <div className="flex items-center gap-4">
                            <ArtDisplay artId={room.artId} size={50} />
                            <div><div className="font-medium text-sm">{room.artName}</div><div className="text-xs text-gray-400">{phaseLabels[room.phase]} | üë• {room.players?.length || 0}</div></div>
                          </div>
                          <button onClick={() => { setCurrentRoomId(room.id); setActiveTab('game'); }} className="btn-warning px-4 py-2 rounded-lg text-white text-sm font-medium">Enter</button>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-2 gap-4">
                  <div className="glass rounded-xl p-4 text-center"><div className="text-2xl mb-1">üéÆ</div><div className="text-2xl font-bold">{globalState.totalGames}</div><div className="text-xs text-gray-500">Total Games</div></div>
                  <div className="glass rounded-xl p-4 text-center"><div className="text-2xl mb-1">üë•</div><div className="text-2xl font-bold">{Object.keys(globalState.leaderboard).filter(a => !isAIPlayer(a)).length}</div><div className="text-xs text-gray-500">Players</div></div>
                </div>
              </div>
            )}

            {activeTab === 'game' && (
              <div className="animate-fade-in">
                {!currentRoom ? (
                  <div className="glass rounded-2xl p-8 text-center"><p className="text-gray-400 mb-4">No active game</p><button onClick={() => setActiveTab('lobby')} className="btn-primary px-6 py-3 rounded-xl text-white font-semibold">Go to Lobby</button></div>
                ) : (
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div className="space-y-4">
                      <div className="glass rounded-xl p-4">
                        <div className="flex items-center justify-between">
                          <span className="px-3 py-1 rounded-full text-sm font-semibold flex items-center gap-2" style={{ background: phaseColors[currentRoom.phase] + '20', color: phaseColors[currentRoom.phase] }}><span className="w-2 h-2 rounded-full pulse-dot" style={{ background: phaseColors[currentRoom.phase] }}></span>{phaseLabels[currentRoom.phase]}</span>
                          {currentRoom.locked && <span className="text-xs text-yellow-500">üîí Room Locked</span>}
                          {(currentRoom.phase === 'playing' || currentRoom.phase === 'voting') && <div className={`px-3 py-1.5 rounded-lg ${timeLeft <= 30 ? 'bg-red-500/20 text-red-400' : 'bg-white/5'}`}><span className="text-xl font-bold font-mono">{formatTime(timeLeft)}</span></div>}
                        </div>
                      </div>

                      <div className="glass rounded-xl p-6 text-center">
                        <ArtDisplay artId={currentRoom.artId} size={300} />
                        {currentRoom.phase === 'waiting' && (
                          <div className="mt-4 p-3 bg-white/5 rounded-lg">
                            <div className="text-sm text-gray-400 mb-2">Players ({currentRoom.players?.length || 0}/{currentRoom.maxPlayers})</div>
                            <div className="flex flex-wrap gap-2 justify-center">
                              {currentRoom.players?.map(addr => (
                                <span key={addr} className={`px-2 py-1 rounded text-xs ${addr === wallet.address ? 'bg-primary-500/30 text-primary-300' : isAIPlayer(addr) ? 'bg-yellow-500/20 text-yellow-300' : 'bg-white/10'}`}>{isAIPlayer(addr) && 'ü§ñ '}{globalState.playerIds[addr] || generatePlayerId(addr)}{addr === currentRoom.creator && ' üëë'}</span>
                              ))}
                            </div>
                            {currentRoom.creator === wallet.address && currentRoom.players?.length >= CONFIG.MIN_PLAYERS && <button onClick={() => handleStartGame(currentRoomId)} className="btn-success w-full mt-4 py-3 rounded-lg text-white font-semibold">üöÄ Start Game (locks room)</button>}
                            {currentRoom.players?.length < CONFIG.MIN_PLAYERS && <p className="text-sm text-yellow-500 mt-3">Waiting for players... (AI joins in {CONFIG.AI_FILL_DELAY}s)</p>}
                          </div>
                        )}
                        {currentRoom.phase === 'playing' && canVoteEnd && (
                          <div className="mt-4 p-3 bg-yellow-500/10 rounded-lg border border-yellow-500/20">
                            <button onClick={handleVoteEndGame} disabled={currentRoom.endGameVotes?.includes(wallet.address)} className={`w-full py-2 rounded-lg font-medium ${currentRoom.endGameVotes?.includes(wallet.address) ? 'bg-white/10 text-gray-500' : 'btn-warning text-white'}`}>{currentRoom.endGameVotes?.includes(wallet.address) ? `‚úì Voted (${endVoteProgress})` : `End Early (${endVoteProgress})`}</button>
                          </div>
                        )}
                      </div>

                      {currentRoom.phase === 'finished' && currentRoom.winner && (
                        <div className="rounded-xl p-6 text-center" style={{ background: 'linear-gradient(135deg, rgba(139,92,246,0.2), rgba(236,72,153,0.2))', border: '1px solid rgba(139,92,246,0.3)' }}>
                          <div className="text-4xl mb-3">üèÜ</div>
                          <h3 className="text-xl font-bold mb-2">Game Over!</h3>
                          <p className="text-sm text-gray-400 mb-3">Winner: {globalState.playerIds[currentRoom.winner] || generatePlayerId(currentRoom.winner)}{isAIPlayer(currentRoom.winner) && ' ü§ñ'}</p>
                          
                          {/* ÊòæÁ§∫Áé©ÂÆ∂XPÊòéÁªÜ */}
                          {currentRoom.xpDetails?.[wallet.address] && (
                            <div className="bg-white/10 rounded-lg p-3 mb-3 text-left">
                              <div className="text-sm font-medium text-gray-300 mb-2">üìä Your XP Breakdown:</div>
                              <div className="space-y-1 text-sm">
                                {currentRoom.xpDetails[wallet.address].winner > 0 && (
                                  <div className="flex justify-between"><span className="text-yellow-400">üèÜ Won the game</span><span className="text-yellow-400">+{currentRoom.xpDetails[wallet.address].winner} XP</span></div>
                                )}
                                {currentRoom.xpDetails[wallet.address].vote > 0 && (
                                  <div className="flex justify-between"><span className="text-green-400">‚úì Voted for winner</span><span className="text-green-400">+{currentRoom.xpDetails[wallet.address].vote} XP</span></div>
                                )}
                                {currentRoom.xpDetails[wallet.address].participate > 0 && (
                                  <div className="flex justify-between"><span className="text-blue-400">üë§ Participated</span><span className="text-blue-400">+{currentRoom.xpDetails[wallet.address].participate} XP</span></div>
                                )}
                                <div className="border-t border-white/10 pt-1 mt-1 flex justify-between font-bold"><span className="text-primary-300">Total</span><span className="text-primary-300">+{currentRoom.xpDetails[wallet.address].total} XP</span></div>
                              </div>
                            </div>
                          )}
                          
                          <button onClick={handleLeaveRoom} className="btn-primary mt-2 px-6 py-2 rounded-lg text-white font-semibold">Back to Lobby</button>
                        </div>
                      )}
                      {currentRoom.phase !== 'finished' && <button onClick={handleLeaveRoom} className="w-full py-2 text-sm text-gray-500 hover:text-gray-300">Leave Room</button>}
                    </div>

                    <div className="space-y-4">
                      {currentRoom.phase === 'playing' && (
                        <div className="glass rounded-xl p-5">
                          <h3 className="font-semibold mb-3">üí¨ Describe the Art</h3>
                          <div className="chat-scroll mb-4 space-y-2 p-2 bg-black/20 rounded-lg min-h-[200px]">
                            {currentRoom.messages?.length === 0 ? <div className="text-center py-8 text-gray-500 text-sm">Start describing!</div> : currentRoom.messages?.map(msg => (
                              <div key={msg.id} className={`p-3 rounded-lg ${msg.author === wallet.address ? 'bg-primary-500/20 ml-8' : isAIPlayer(msg.author) ? 'bg-yellow-500/10 mr-8' : 'bg-white/5 mr-8'}`}>
                                <div className="flex justify-between items-start mb-1"><span className="text-xs font-medium text-gray-400">{isAIPlayer(msg.author) && 'ü§ñ '}{globalState.playerIds[msg.author] || generatePlayerId(msg.author)}</span><span className="text-xs text-gray-500">{new Date(msg.timestamp).toLocaleTimeString()}</span></div>
                                <p className="text-gray-200">{msg.content}</p>
                              </div>
                            ))}
                            <div ref={chatEndRef} />
                          </div>
                          <div className="flex gap-2">
                            <input type="text" value={message} onChange={e => setMessage(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleSendMessage()} placeholder="Describe the art..." className="flex-1 px-4 py-2 rounded-lg bg-black/30 border border-white/10 text-gray-200 focus:outline-none focus:border-primary-500/50" />
                            <button onClick={handleSendMessage} disabled={!message.trim()} className={`px-4 py-2 rounded-lg font-medium ${message.trim() ? 'btn-success text-white' : 'bg-white/10 text-gray-500'}`}>Send</button>
                          </div>
                        </div>
                      )}

                      {currentRoom.phase === 'voting' && (
                        <div className="glass rounded-xl p-5">
                          <h3 className="font-semibold mb-2">üó≥Ô∏è Vote for Best Description</h3>
                          <p className="text-xs text-gray-400 mb-4">Correct vote = +{CONFIG.CORRECT_VOTER_EXP} XP | Participate = +{CONFIG.PARTICIPANT_EXP} XP</p>
                          <div className="space-y-3">
                            {[...new Set(currentRoom.messages?.map(m => m.author) || [])].map(addr => {
                              const authorMsgs = currentRoom.messages?.filter(m => m.author === addr) || [];
                              const isVoted = currentRoom.votes?.[wallet.address] === addr;
                              const voteCount = Object.values(currentRoom.votes || {}).filter(v => v === addr).length;
                              return (
                                <div key={addr} onClick={() => !currentRoom.votes?.[wallet.address] && handleVote(addr)} className={`p-4 rounded-lg transition ${isVoted ? 'bg-primary-500/20 border border-primary-500/40' : 'bg-white/5 border border-white/5'} ${!currentRoom.votes?.[wallet.address] ? 'cursor-pointer hover:bg-white/10' : ''}`}>
                                  <div className="flex justify-between items-center mb-2"><span className="text-sm font-medium">{isAIPlayer(addr) && 'ü§ñ '}{globalState.playerIds[addr] || generatePlayerId(addr)}{addr === wallet.address ? ' (You)' : ''}</span><span className="text-yellow-500 text-sm">üó≥Ô∏è {voteCount}</span></div>
                                  <div className="space-y-1">{authorMsgs.slice(0, 2).map((m, i) => <p key={i} className="text-sm text-gray-300 truncate">"{m.content}"</p>)}</div>
                                  {isVoted && <div className="mt-2 text-sm text-primary-400">‚úì Your vote</div>}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      )}

                      {currentRoom.phase === 'finished' && (
                        <div className="glass rounded-xl p-5">
                          <h3 className="font-semibold mb-4">üìä Final Results</h3>
                          <div className="space-y-2">
                            {[...new Set(currentRoom.messages?.map(m => m.author) || [])].sort((a, b) => (currentRoom.voteCount?.[b] || 0) - (currentRoom.voteCount?.[a] || 0)).map(addr => (
                              <div key={addr} className={`p-3 rounded-lg ${addr === currentRoom.winner ? 'bg-yellow-500/20' : 'bg-white/5'}`}>
                                <div className="flex justify-between"><span>{addr === currentRoom.winner && 'üèÜ '}{isAIPlayer(addr) && 'ü§ñ '}{globalState.playerIds[addr] || generatePlayerId(addr)}</span><span className="text-yellow-500">{currentRoom.voteCount?.[addr] || 0} votes</span></div>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}

            {activeTab === 'history' && (
              <div className="glass rounded-2xl p-6 animate-fade-in">
                <h2 className="text-2xl font-bold text-center gradient-text mb-6">üìú Game History</h2>
                {!wallet.connected ? <div className="text-center py-10 text-gray-500">Connect wallet to view history</div> : myGameHistory.length === 0 ? <div className="text-center py-10 text-gray-500">No games played yet</div> : (
                  <div className="space-y-3">
                    {myGameHistory.map((game) => {
                      const myXP = game.xpDetails?.[wallet.address] || { winner: 0, vote: 0, participate: 0, total: 0 };
                      const isWinner = game.winner === wallet.address;
                      const isRecent = game.id === lastFinishedGameId;
                      return (
                        <div key={game.id} className={`p-4 rounded-xl ${isRecent ? 'ring-2 ring-primary-500 bg-primary-500/10' : isWinner ? 'bg-yellow-500/10 border border-yellow-500/20' : 'bg-white/5'}`}>
                          <div className="flex items-center justify-between">
                            <div className="flex items-center gap-3">
                              <ArtDisplay artId={game.artId} size={50} />
                              <div>
                                <div className="font-medium text-sm">{game.artName}</div>
                                <div className="text-xs text-gray-400">Game #{game.gameNumber} | {new Date(game.finishedAt).toLocaleDateString()}</div>
                                <div className="text-xs text-gray-500 mt-1">Winner: {globalState.playerIds[game.winner] || generatePlayerId(game.winner)}{isAIPlayer(game.winner) && ' ü§ñ'}</div>
                              </div>
                            </div>
                            <div className="text-right">
                              {/* XPÊòéÁªÜ */}
                              <div className="space-y-0.5 text-xs">
                                {myXP.winner > 0 && <div className="text-yellow-400">üèÜ +{myXP.winner} XP</div>}
                                {myXP.vote > 0 && <div className="text-green-400">‚úì +{myXP.vote} XP</div>}
                                {myXP.participate > 0 && <div className="text-blue-400">üë§ +{myXP.participate} XP</div>}
                              </div>
                              <div className="text-sm text-primary-300 font-bold mt-1">Total: +{myXP.total || (isWinner ? CONFIG.WINNER_EXP : CONFIG.PARTICIPANT_EXP)} XP</div>
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            {activeTab === 'leaderboard' && (
              <div className="glass rounded-2xl p-6 animate-fade-in">
                <h2 className="text-2xl font-bold text-center gradient-text-gold mb-6">üèÜ Rankings</h2>
                {sortedLeaderboard.length === 0 ? <div className="text-center py-10 text-gray-500">No players yet</div> : (
                  <div className="space-y-2">
                    {sortedLeaderboard.map((p, idx) => (
                      <div key={p.address} className={`grid grid-cols-[40px_1fr_80px_80px_60px] items-center p-3 rounded-lg ${idx === 0 ? 'bg-yellow-500/10' : p.address === wallet.address ? 'bg-primary-500/10' : 'bg-white/3'}`}>
                        <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-sm font-bold ${idx < 3 ? 'bg-gradient-to-br from-yellow-400 to-orange-500' : 'bg-white/10'}`}>{idx < 3 ? ['ü•á', 'ü•à', 'ü•â'][idx] : idx + 1}</div>
                        <span className="text-sm font-medium truncate">{p.playerId}{p.address === wallet.address && ' (You)'}</span>
                        <div className="text-center"><div className="font-bold text-primary-300">{p.experience}</div><div className="text-[10px] text-gray-500">XP</div></div>
                        <div className="text-center"><div className="font-bold text-green-400">{p.wins}</div><div className="text-[10px] text-gray-500">Wins</div></div>
                        <div className="text-center"><div className="font-bold text-gray-300">{p.participations}</div><div className="text-[10px] text-gray-500">Games</div></div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </main>

          <footer className="text-center py-6 border-t border-white/5 mt-8"><p className="text-sm text-gray-500">Consensus Gallery | <a href="https://genlayer.com" target="_blank" className="text-primary-400 hover:underline">GenLayer</a></p></footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
